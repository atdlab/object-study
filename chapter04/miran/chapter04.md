# CHAPTER.04 설계 품질과 트레이드오프

`객체지향 설계의 핵심`은 `역할, 책임, 협력`

`협력`은 애플리케이션 기능을 구현하기 위해 메시지를 주고받는 `객체들 사이의 상호작용`

`책임`은 `객체가` 다른 객체와 협력하기 위해 `수행하는 행동`

`역할`은 `대체 가능한 책임의 집합`

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동

객체지향의 관점

1. 객체지향 설계의 핵심은 책임
2. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연결되어있다.

쉽게 변경할 수 있는 설계는 `응집도가 높고 결합도가 낮게` 구성되어있다. 결합도와 응집도는 객체의 상태가 아니라 행동에 초점을 맞춰야 한다. 즉 객체의 책임에 초점을 맞추고 나아가 객체와 객체 사이의 상호작용으로 설계의 중심을 맞추면 결합도가 낮고 응집도가 높으며 효과적으로 캡슐화하는 객체들을 만들 수 있다.

# 데이터 중심의 영화 예매 시스템

객체지향 설계에서 시스템 객체로 분할 하는 방법

1. 상태(데이터)를 분할의 중식축으로 삼는 방법
    - 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의
    - 객체의 상태에 초점
    - 객체는 독립된 덩어리이다
2. 책임을 분할의 중심축으로 삼는 방법
    - 객체가 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관
    - 객체의 행동에 초점
    - 객체는 협력하는 공동체의 일원이다

데이터에 초점을 맞추는 설계는 변경에 취약하다

- 객체의 상태는 구현에 속한다
    - 구현은 불안정하기 때문에 변하기 쉽다
    - 상태를 초점으로 삼으면 구현에 관한 세부 사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.
    - 이는 상태가 변경할 때 인터페이스가 변경되며 이 인터페이스에 의존하는 모든 객체에게 영향을 준다.
- 객체의 책임은 인터페이스에 속한다
    - 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 상태를 캡슐화함으로 구현에 대한 파장이 외부로 퍼져나가는 것을 방지한다

## 데이터를 준비하자

데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.

- 책임 중심 설계
    - 시작 → 책임이 무엇인가?
    - DiscountPolicy가 할인 조건과 할인 정책을 정의
- 데이터 중심 설계 - Movie
    - 시작 → 객체가 내부에 저장해야 하는 데이터가 무엇인가?
    - Movie에서 할인 조건의 목록 포함
    - 할인 정책을 직접 정의
        - movieType이 현재 영화에 설정된 할인 정책의 종류를 결정
        movieType의 값이 AMOUNT_DISCOUNT → discountAmount, PERCENT_DISCOUNT → discountPercent에 저장된 값을 사용. NONE_DISCOUNT이라면 아무것도 사용안함
        - 객체의 종류를 저장하는 인스턴스 변수(movieType)와 인스턴스의 종류에 따라 베타적으로 사용될 인스턴스 변수(discountAmount, discountPercent)를 함께 포함
    
    > 내부의 데이터를 반환하는 접근자(accessor)와 데이터를 변경하는 수정자(mutator)를 추가해야 내부 데이터가 객체의 엷은 막을 빠져나가 외부의 다른 객체들을 오염 시키는 것을 막을 수 있다.
    > 
- 데이터 중심 설계 - DiscountCodition
    - 할인 조건의 종류를 저장할 데이터(DiscountCoditionType)가 필요
    - 할인 조건을 저장할 인스턴스 변수인 type포함
    - 할인 조건들에서 사용되는 데이터인 상영순번(sequence), 요일(datOfWeek), 시작 시간(startTime)과 종료시간(endTime)을 포함
    - 이 속성들을 외부 클래스에 노출되는 것을 막을(캡슐화의 원칙에 따라) 메서드를 추가
- 데이터 중심 설계 - Screening
    - 영화 정보를 가진 Movie, 영화 시작 시간, 입장 순서를 포함한다.
- 데이터 중심 설계 - Reservation
    - 고객 정보를 담을 Customer, 영화 정보를 담은 Screening, 영화요금(fee), 관객수(audienceCount)를 포함
- 데이터 중심 설계 - Customer
    - 고객의  name, id 포함

## 영화를 예매하자

ReservationAgency는 데이터 클래스들을 조합해서 영화 예매 절차를 구현하는 클래스

- reserve메서드를 포함
    - DiscountCondition에 대해서 돌면서 할인 가능 여부를 확인하는 for문
        - DiscountCondition타입이 기간 조건이라면 기간을 이용해 적용 여부 판다
        - DiscountCondition타입이 순번 조건이라면 상영 순번을 이용해 조건 판단
    - discountable 변수의 값을 체크하고 적절한 할인 정책에 따라 예매 요금을 계산하는 if문
        - discountable에 할인 여부를 저장
        - discountable이 true라면 만족하는 할인 조건이 존재
        - discountable이 false라면 만족하는 할인 조건이 존재하지 않음
    - 금액 할인 정책이라면 할인 금액을 이용해 요금 계산
    - 비율 할인 정책이라면 할인 비율을 이용해 요금 계산
    - 할인 정책이 정의되지 않았다면 기본 요금을 이용해 요금을 계산
    - 계산된 요금은 Reservation 인스턴스를 생성할 때 사용

# 설계 트레이드오프

## 캡슐화

캡슐화란 변경 가능성이 높은 부분(구현)을 객체 내부로 숨기는 추상화의 기법이다. 캡슐화가 중요한 이유는 불안정한 부분과(구현) 안정적인 부분(인터페이스)을 분리해서 외부에서는 인터페이스만 의존하도록 하고 구현은 감춤으로써 변경의 영향을 통제할 수 있기 때문이다. 객체 내부에서  변경될 수 있는 어떠한 것이라도 캡슐화 해야 한다.

> 객체 지향 언어를 사용한다고 해서 복잡성이 잘 캡슐화 될 것이라고 보장할 수 없다. 오직 설계 과정 동안 캡슐화를 목표로 인식할 때 만 달성될 수 있다.
> 

> 캡슐화로 뜻밖의 피해가 발생할 수 있는 가능성을 사전에 방지할 수 있다. 우리는 변경으로부터 완전히 자유로워질 수 있다. 응집도, 결합도, 중복 역시 변경 가능한 코드를 규정하는데 핵심적인 품질인 것은 사실이지만 캡슐화는 우리를 좋은 코드로 안내하기 때문에 가장 중요한 제 1원리다.
> 

## 응집도와 결합도

응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 목적이 같고 긴밀할 수록 높아진다. 객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다. 객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 관계 만을 유지하고 있는 것이 좋다.

좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다. 높은 응집도와 낮은 결합도를 추구해야 설계를 변경하기 쉽게 만 들수 있다. 

변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다. 하나의 변경에 따라 모듈이 변경 해야 하는 수가 많을수록 응집도가 낮은 것이다. 응집도가 높을 수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.

변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다. 결합도가 높을수록 함께 변경 해야 하는 수가 많아지기 때문에 변경하기 어려워진다. 또한 변경의 원인을 이용해 결합도를 말할 수도 있다. 내부 구현을 변경했을 때 다른 모듈에 영향을 미치는 경우 두 모듈 간의 결합도가 높다고 표현할 수 있다. 따라서 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.

캡슐화는 응집도와 결합도에 영향을 미친다. 캡슐화를 지키면 모듈안의 응집도는 높아지고 모듈사이의 결합도는 낮아진다. 그러므로 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상 시키려고 해야 한다.

# 데이터 중심의 영화 예매 시스템의 문제점

## 캡슐화 위반

Movie의 경우 fee값을 읽거나 수정하기 위해서는 getFee, setFee를 사용해야하기 때문에 캡슐화 되어있는 것처럼 보이지만 getFee, setFee는 Movie내부에 Money타입의 fee라는 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노출한다.

객체에게 중요한 것은 책임이다 구현을 캡슐화 할 수 있는 책임은 협력을 고려할 때만 얻을 수 있다. 그렇지 않을 경우 과도한 접근자와 수정자를 가질 수 있다. 객체가 사용될 협력을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서도 당 객체가 사용될 수 있게 많은 접근자를 추가 하게 된다.

이처럼 과도한 접근자와 수정자를 가진 설계 방식을 추측에 의한 설계 전략(design-byguessing stratege)라고 부른다. 이 전략은 객체가 다양한 상황에서 사용될 수 있게 내부 상태를 많이 추가 해야 한다는 압박에 시달릴 수 밖에 없고 그래서 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없는 것이다. 

## 높은 결합도

1. 객체의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미하기 때문에 **객체 내부 구현을 변경할 때도 이 인터페이스에 의존하는 모든 클라이언트를 변경해야 한다.**
    
    ReservationAgency는 한 명의 예매 요금을 계산하기 위해서는 `Movie의 getFee메서드를 호출 → 계산된 결과를 Money타입의 fee에 저장한다`
    
    만약 fee타입을 바꾼다면 `ReservationAgency에서 getFee메서드를 호출하는 구현 변경 → getFee에서 반환되는 타입도 변경`해야한다
    
    fee에 따라 협력하는 클래스가 변경되기 때문에 fee의 가시성을 private에서 public으로 변경하는 것과 같다. 
    
2. 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 **어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경 할 수 밖에 없다.**
    
    ReservationAgency는 모든 객체에 의존한다. DiscountCondition이 변경되면 ReservationAgency도 변경 해야 한다. 시스템의 어떠한 것을 변경하더라도 ReservationAgency변경해야 한다.
    

데이터 중심의 설계는 결합도가 높기 때문에 전체 시스템이 하나의 의존성 덩어리가 되어 어떤 변경이 발생된다면 전체 시스템이 요동칠 수 밖에 없다.

## 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 응집도가 낮다고 말한다. 응집도를 살펴보기 위해서는 코드를 수정하는 이유가 무엇인가 알아보아야 한다.

ReservationAgency의 경우 할인 정책(조건)이 추가, 변경될 경우나 예매 요금 계산 방법이 변경 될 경우에도 수정되어야 한다.

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다

- 서로 다른 코드들을 한 모듈 안에 뭉쳐 놨기 때문에 변경과 아무 상관이 없는 코드들도 영향을 미친다. 어떤 코드를 수정한 후에 아무런 상관 없던 코드에 문제가 발생하게 되는 경우가 많다.
- 하나의 요구 사항을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 책임의 일부가 엉뚱한 곳에 위치 하기 때문이다.

> **단일책임의 원칙(SRP)**
클래스는 단 하나의 변경 이유를 가져야 한다. 단, 단일 책임의 원칙에서는 ‘책임’이라는 말이 ‘변경의 이유’로 사용된다는 점을 주의해야 한다.
> 

# 자율적인 객체를 향해

## 캡슐화를 지켜라

캡슐화는 설계의 제1원리다. 객체는 자신이 어떤 데이터를 가지고 있는 지를 내부에 캡슐화하고 외부에 공개해서는 안된다. `객체는 스스로의 상태를 책임져야 하며, 외부에서는 인터페이스에 정의된 메서드를 이용해서 만 상태에 접근할 수 있어야 한다.`

객체에게 메서드는 객체가 책임져야 할 무언가를 수행하는 메서드이다. 속성을 private로 설정했더라도 접근자나 수정자 메서드가 속성을 외부에 제공하고 있다면 캡슐화 위반이다.

- getRight, getBottom처럼 다른 곳에서도 사용될 가능성이 있는 코드를 제거해서 코드 중복을 초래할 수 있는 모든 원인을 제거하는 것이 중요하다
- Retangle을 변경하는 주체를 외부의 객체(AnyClass)에서 Retangle 스스로 증가 시키도록 ‘책임을 이동’ 시켜서 캡슐화를 강화해야 한다.

## 스스로 자신의 데이터를 책임지는 객체

상태와 행동을 객체 하나로 묶는 이유는 스스로 자신의 상태를 처리할 수 있게 하기 위해서지 단순히 데이터 제공자가 아니다.  그렇기 때문에 데이터보다는 객체가 협력에 참여하면서 수행할 책임을 정의 하는 것이 더 중요하다. 아래의 질문을 조합하면 내부 상태를 저장하는 방식과 상태를 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다. 즉 데이터 타입을 만들 수 있다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

ReservationAgency로 새어나간 데이터에 대한 책임을 실제 데이터를 포함하고 있는 객체로 옮겨보자. 데이터를 처리하는데 필요한 메서드를 데이터를 가지고 있는 객체 스스로 구현하도록 말이다.

- DiscountCondition
    1. 어떤 데이터를 관리해야 하는가?
        
        DiscountConditionType, sequence, dayOfWeek, startTime, endTime
        
    2. 이 데이터에 대해 수행할 수 있는 오퍼레이션이 무엇인가?
        
        type을 이용해 기간 조건, 할인 조건에 맞는 적절한 메서드가 호출됐는지 판단할 수 있게 각각의 isDiscountable이 필요하다.
        
- Movie
    1. 어떤 데이터를 포함해야 하는가?
        
        title, runningTime, fee, discountConditions, movieType, discountAmount, discountPercent
        
    2. 이 데이터를 처리하기 위해 어떤 오퍼레이션이 필요한가?
        - 영화 요금을 계산하는 오퍼레이션
            
            할인 정책 타입을 반환하는 getMovieType과 금액 할인, 비율 할인, 할인 미적용별로 요금을 계산할 수 있는 caculateAmountDiscountedFee, caculatePercentDiscountedFee, caculateNoneDiscountedFee가 필요하다.
            
        - 할인 여부를 판단하는 오퍼레이션
            
            기간 조건이나 순번 조건을 판단하기 위해 필요한 dayOfWeek, whenScreened, sequence를 파라미터로 전달해주는 isDiscountable이 필요하다
            
- Screening
    - 필요한 데이터: movie, sequence, whenScreened
    - 필요한 메서드:  할인 정책에 따라 할인이 가능한지 알려주는 isDiscountable, 각 할인 정책에 따라 요금을 계산할  caculateAmountDiscountedFee, caculatePercentDiscountedFee 할인 정책이 적용되지 않은 요금을 계산하는 cacluateNoneDiscountFee를 호출하는 caculateFee가 필요하다
- ReservationAgency는 Screening의 caculateFee를 호출해 예매 요금을 계산한 후 Reservation을 생성하도록 변경되었다.

# 하지만 여전히 부족하다

## 캡슐화 위반

DiscountCondition은 스스로 할인 여부를 판단한다. 그렇지만 두 개의 isDiscountable을 살펴보면  시그니처를 통해 DayOfWeek, LocalTime, sequence를 인스턴스 변수로 포함되었다는 상태을 인터페이스를 통해 노출 하고 있다.

만약 DiscountCondtion의 속성을 변경하는 경우 isDiscountable의 파라미터를 수정하고 그 메서드를 사용하는 모든 클라이언트도 수정해야 한다. 그렇기 때문에 내부 구현을 캡슐화 하는 것은 실패한 것이다.

Movie의 경우 요금 계산 메서드들은 내부에 포함된 속성을 노출 시키지 않지만, caculateAmountDiscountedFee, caculatePercentDiscountedFee, caculateNoneDiscountedFee를 통해 할인 정책의 종류를 노출 시키므로 역시 내부 구현을 인터페이스에 노출 시키고 있다.

캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는 다면 캡슐화를 위반한 것이다. `설계에서 변하는 것이 무엇인지 고려하고 변하는 모든 개념을 캡슐화 해야 한다.`

## 높은 결합도

두 객체의 결합도가 높을 경우 한 객체의 구현을 변경할 때 다른 객체에게 변경의 영향이 전파될 확률이 높아진다.

Movie의 isDiscountable은 DiscountCondition 목록에서 할인 조건의 종류에 따라 isDiscountable을 선택해 호출한다. DiscountCondition에서 종류나 할인 조건의 명칭, 만족 여부를 판단하는 어떠한 정보가 변경된다면 Movie의 구문이나 isDiscountable의 파라미터 및 시그니처가 변경되어야 하므로 결과적으로는 Screening까지 변경을 할 수 도 있다.

그렇기 때문에 유연한 설계를 위해서는 캡슐화를 설계의 첫 번째 목표로 삼아야 한다.

## 낮은 응집도

하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경한다는 것은 설계의 응집도가 낮다는 것이다. 응집도가 낮은 이유는 캡슐화를 위반했기 때문이다. 내부 구현이 인터페이스에 노출되어 있다면 그와 연결되어있는 객체는 그 구현을 의존하게 된다.

# 데이터 중심 설계의 문제점

## 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다

데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다. 데이터와 기능을 분리하는 절차적 프로그래밍 방식은 상태와 행동을 하나의 단위로 캡슐화하는 객체지향 패러다임에 반하는 것이다.

- 데이터 중심 설계에서 객체는 단순히 데이터의 집합체일 뿐이다. 이로 인해 public의 속성과 다를 게 없는 수정자와 접근자를 과도하게 추가하게 되고 데이터 객체를 사용하는 절차와 분리된 다른 객체 안에 구현하게 한다.
- 같은 객체 안에 작업과 데이터를 두더라도 데이터에 관한 지식이 객체의 인터페이스에 드러나게 되면 객체의 인터페이스는 구현을 캡슐화하는데 실패하고 코드는 변경에 취약해진다.

## 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 한다.

객체지향 애플리케이션을 구현한다는 것은 협력하는 객체들이 공동체를 구축한다는 것을 의미한다.

올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 데이터를 가지고 그것을 관리하는 것보다 중요한 것은 객체가 다른 객체와 협력하는 방법이다.

데이터 중심의 설계는 외부가 아니라 내부로 초점을 맞추고 객체가 관리할 데이터의 세부 정보를 먼저 결정하기 때문에 객체의 구현이 이미 결정된 객체의 인터페이스에 억지로 끼어 맞춰야 한다.

객체의 인터페이스에 구현이 노출되어 있기 때문에 협력이 구현 세부 사항에 종속되어 있고 그에 따라 객체 내부 구현이 변경 되었을 때 협력하는 모든 객체가 영향을 받을 수 밖에 없다