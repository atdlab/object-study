# 의존성

- 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 생긴다.
- 실행 시점 - 객체가 정상적으로 동작하기 위해서는 **실행 시에 의존 대상 객체가 반드시 존재**해야 한다.
- 구현 시점 - **의존 대상의 객체가 변경될 경우 의존하는 객체도 함께 변경된다**.
    - 의존성은 방향성을 가지며 단 방향이다.
    - 의존성은 의존 되는 요소가 변경 될 때 의존하는 요소도 함께 변경될 수 있다.
- 관점에 따라 **의존성의 대상이 가지는 특징이 다를 수 있다.**
- 의존성의 **종류를 구분 가능하도록 서로 다른 방식으로 표현하는 것이 유용**하다
- **UML에서 정의하는 두 요소 사이의 관계**
    - 실체화 관계(realization)
    - 연관 관계(association)
    - 의존 관계(dependency)
    - 일반화/특수화 관계(generalization/specialization)
    - 합성 관계(composition)
    - 집합 관계(aggregation)
    
    UML에서는 두 요소 사이에 존재할 수 있는 여러 관계 중에 의존 관계를 정의하지만, 우리가 말하는 의존성은 두 요소 사이에 변경에 의해 영향을 주고 받는 지에 초점을 맞춘다. 
    

## 의존성의 전이(transitive dependency)

- 의존성은 전이 될 수 있다.
- 의존하는 요소(A)는 의존 되는 요소(B)가 의존하고 있는 요소(C)를 자동적으로 의존하게 된다.
- 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 전이 되는 것은 아니다. 캡슐화 되어 있다면 변경이 전파되지 않을 수 있다.

## 의존성의 종류

### **직접 의존성(direct dependecy)**

한 요소가 다른 요소에 직접 의존하는 경우를 말하며, 코드에 명시적으로 드러난다.

### **간접 의존성(indirect dependency)**

직접적인 관계는 존재 하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 말한다.

### 런타임 의존성(run-time dependency)

객체지향 애플리케이션에서 런타임의 주인공은 객체다. 런타임 의존성 이란 곧 객체 사이의 의존성을 말한다.

### 컴파일타임 의존성(compile-time dependency)

여기서 컴파일 시점이란 컴파일 되는 시점을 말하는 것이 아니라 코드가 작성되는 때를 말한다. 코드의 구조를 주목해야 한다. 코드의 관점에서 주인공은 클래스다. 컴파일타임 의존성 이란 곧 클래스의 의존성을 말한다.

```java
런타임 의존성과 컴파일타임 의존성은 다를 수 있다. 
유연하고 재사용 가능한 코드를 설계하려면 **두종류의 의존성을 서로 다르게 만들어야한다**.
동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.
**어떤 클래스가 협력할 인스턴스의 클래스를 알아서는 안된다.**
실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.
**클래스가 협력할 클래스를 명시적으로 드러낸다면 다른 인스턴스와 협력할 가능성이 없어진다.**
컴파일타임의 구조와 런타임의 구조사이의 거리가 멀수록 설계가 유연해진다.
```

### 컨텍스트 독립성

클래스가 사용될 특정한 문맥에 대해 최소한의 가정 만으로 이뤄지는 것을 말한다. 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 더 다양한 컨텍스트에서 재사용 될 수 있기 때문이다.

## 의존성 해결하기

컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 말한다.

### 객체를 생성하는 시점에 생성자를 통해 의존성 해결

객체를 생성 할 때 의존성을 해결한 후 완전한 상태의 객체를 생성한다.

### 객체 생성 후 setter 메서드를 통해 의존성 해결

객**체를 생성한 이후에도 의존하고 있는 대상을 변경**할 수 있는 가능성을 열어 놓고 싶은 경우에 유용하다. **실행 시점에 의존 대상을 변경**할 수 있기 때문에 설계를 좀 더 유연하게 할 수 있다. 단점은 객체가 생성한 후 의존 대상을 설정하기 때문에 그 전까지 객체의 상태가 불완전 할 수 있다는 것이다.

```java
생성자 방식과 setter방식을 혼합하는 것도 좋다. 
의존성이 해결된 객체를 생성한 후, 필요할 때 setter를 통해 의존 대상을 변경하면 
시스템의 상태를 안정적으로 유지하면서 유연성을 향상 시킬 수 있어서 가장 많이 선호된다.
```

### 메서드 실행시 인자를 이용해 의존성 해결

협력 대상에 대해 **지속적으로 의존 관계를 맺을 필요 없이** 메서드가 실행되는 동안만 **일시적으로 의존 관계**가 존재해도 무방하거나 **메서드가 실행될 때마다 의존 대상이 매번 달라져야 할 경우** 유용하다.

## 바람직한 의존성

의존성의 존재하는 것이 바람직하지 않은 것은 아니다. 의존성은 협력을 가능하게 만든다. 단지 정도가 문제이다. 의존성의 정도는 결합도로 표현된다. 의존성이 높을 경우 결합도가 강하다. 의존성이 낮을 경우 결합도가 약하다라고 말한다.

바람직한 의존성은 재사용성과 관계가 있다. 다양한 환경에서 재사용 할 수 없게 제한 한다면 올바르지 않다. 컨텍스트에 독립적인 의존성이 바르고, 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않다.

객체에 직접적으로 의존하기보다는 추상화를 통해 간접적으로 의존해 다른 인스턴스와 협력을 가능하게 설계해야 한다.

## 추상화와 의존성

추상화와 결합도 관점에서 의존 대상의 결합도는 `**구체 클래스 > 추상 클래스 > 인터페이스**` 순으로 느슨해진다.

### 구체 클래스 의존성(concrete class dependcy)

- 내부 구현과 자식클래스의 종류에 대한 지식이 드러난다.

### 추상 클래스 의존성 (abstract class dependcy)

- 내부 구현과 자 식클래스의 종류에 대한 지식을 숨길 수 있다.
- 협력하는 대상이 속한 클래스 상속 계층이 무엇인지 대해서 알고 있어야 한다.

### 인터페이스 의존성 (interface dependcy)

- 내부 구현과 자식 클래스의 종류에 대한 지식을 숨길 수 있다.
- 협력하는 대상이 속한 클래스 상속 계층이 무엇인지 몰라도 협력이 가능하다.

### 명시적인 의존성(explicit dependency)

의존성의 대상을 생성자의 인자로 전달 방법을 말한다. 퍼블릭 인터페이스에 의존 하는 요소와 의존 되는 요소의 관계를 노출 시키는 것이다. 다른 컨텍스트에서 재사용 할 경우 코드를 직접 수정하지 않아도 된다. 실행 시점에 적절한 의존성을 선택 할 수 있기 때문이다. 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 런타임 의존성으로 교체할 수 있다.

### 숨겨진 의존성(hidden dependency)

생성자 안에서 의존성의 대상을 직접 생성하는 방법이다. 이는 의존하는 요소들의 의존성을 감춘다. 즉 퍼블릭 인터페이스에 노출 시키지 않는다. 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴보아야 하고 다른 컨텍스트에서 재사용 할 경우 내부 구현을 직접 변경해야 한다.

## new(새로 생성)하는 것을 조심하자

### new가 위험한 이유는 결합도가 극단적으로 높아질 수 있기 때문이다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클래스는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없으므로 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스 뿐 아니라 어떤 인자를 이용해 생성자를 호출해야 하는지도 알아야 하기 때문에 정보를 노출 시키고 결합도가 높아진다.

### new대신 의존성을 해결하는 방법

- 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직으로 분리한다.
- 인스턴스를 생성하지 않고 외부의 인스턴스를 전달 받아 사용하기만 한다.
    - 생성자의 인자로 전달 받는다
    - setter 메서드를 사용한다
    - 실행시에 메서드의 인자로 전달한다.
- 단지, 사용하는 인스턴스에 메시지를 전송하는 코드는 노출해야한다.

### new를 사용하는 것이 유용한 경우

- 협력하는 기본 객체를 설정하고 싶은 경우
- 메서드를 오버라이딩하는 경우
- 변경될 확률이 거의 없는 클래스의 경우
    - 그러나 확장성 측면에서 추상적인 타입을 사용하는 것이 설계의 유연성을 높일 수 있다.

**유연하고 재사용 가능 한 설계는 작은 객체의 행동을 조합함으로써 새로운 행동을 이끌어 낼 수 있는 설계다. 훌륭한 객체는 `어떻게 하는지` 보다 객체들의 조합을 선언적으로 표현하면서 객체가 `무엇을 하는지`를 표현하는 설계다.**