# CHAPTER0.05 책임 할당하기

책임 할당은 일종의 트레이드오프 활동이다. 동일한 문제를 해결할 다양한 책임 할당 방법이 존재한다. 올바른 책임 할당을 위해서는 다양한 관점에서 설계를 평가 할 수 있어야 한다.

이번 장은 GRASP 패턴을 이해하고 책임 할당에 대한 답을 찾는 것이다. 응집도, 결합도, 캡슐화 같은 다양한 기준으로 책임을 할당하고, 결과를 트레이드오프 할 수 있는 기준을 알아보자

# 책임 주도 설계를 향해

책임 주도 설계의 기준. `즉, 데이터가 아닌 객체에 초점`을 맞춰야 한다.

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

## 데이터보다 행동을 먼저 결정하라

객체에게 중요한 것은 `외부에 제공되는 행동(책임) > 데이터(객체가 책임을 수행하는데 필요한 재료)`

책임을 초점에 맞춘 설계를 위한 질문

- 이 객체가 수행해야 하는 책임은 무엇인가?
- 이 책임을 수행하는데 필요한 행동은 무엇인가?

## 협력이라는 문맥 안에서 책임을 결정하라

객체는 협력에 적합한 지의 유무에 따라 좋고 나쁨이 결정된다. 책임은 객체가 아닌 객체가 참여하는 협력`=메시지 전송자`에 적합해야 한다

협력에 적합한 책임을 결정하는 방법

```html
(x) 객체를 결정 → 메시지 선택 
(o) 메시지 선택 → 객체를 결정
```

즉, 클라이언트는 수신자를 모른 채`=캡슐화`  자신의 의도가 담긴 메시지를 보내고 메시지를 수신 받은 객체는 메시지를 처리할 책임을 할당 받게 된다.

## 책임 주도 설계

책임 주도 설계 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하고, 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 객체 내부 상태에 관심을 가지지 않는 것이다

# 책임 할당을 위한 GRASP 패턴

GRASP(일반적인 책임 할당을 위한 소프트웨어 패턴)을 이용해 예매 시스템을 다시 구현해보자

## 올바른 도메인 모델이란 존재하지 않는다.

1.  도메인 모델은 구현을 염두에 두고 구조화되어야 한다.
2. 코드의 구조가 도메인을 바라보는 관점을 바꾸기도 한다.
3. 도메인 모델의 구조가 코드의 구조에 영향을 미친다.
4. 유연성이나 재 사용성 같은 실제 코드를 구현하면서 도메인에 대한 개념이 바뀐다.
5. 필요한 도메인 모델은 구현에 도움이 되는 실용적이면서 유용한 모델이다.

## Information Expert 패턴

1. 전송할 객체는 무엇을 원하는가?
    
    예매 시스템의 책임은 영화를 예매하는 것이다. 그러므로 객체가 원하는 것은 영화를 예매하는 것이고, 우리는 그것으로 `예매하라`라는 메시지를 결정할 수 있다. 
    
2. 메시지를 수신할 객체는 누구인가?
    
    객체를 선택할 때에는 메시지를 처리할 수 있는 객체에게 책임을 할당 해야 한다. **Information expert 패턴에서는 `책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 할당`하라고 한다.** 정보와 패턴이 최대한 가까운 곳에 위치할 수 있으면 캡슐화를 유지할 수 있고, 필요한 정보를 가진 객체들로 분산 되기 때문에 높은 응집도와 낮은 결합도를 만들 수 있다.
    

영화 예매를 위한 설계를 할 때 영화를 예매하기 위한 필요한 정보를 가장 많이 알고 있는 객체를 찾아야 한다. 상영 영화, 상영 시간, 상영 순번을 알고 있는 Screening에게 ‘예매하라’는 책임을 할당 한다. 

Screening은 예매하라는 메시지를 수신 받고 메시지를 처리하기 위해 필요한 절차와 구현을 고민해야 한다. 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇인지 가리고, 스스로 처리할 수 없는 작업을 새로운 메시지로 다른 객체에게 할당해야 한다.

예매하라는 메시지를 처리하기 위해 예매 가격을 계산해야 하고 가격에 인원수를 곱해 예매 가격을 계산할 수 있으나, 가격을 모르는 Screening은 ‘가격을 계산하라’는 메시지를 가격을 계산하기 위해 필요한 정보를 가장 많이 알고 있는 객체(Movie)에게 메시지를 전송한다.

이런 식으로 Infomation expert 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 원칙이다. 이것을 따르는 것 만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구성할 수 있다.

## Low Coupling(낮은 결합도) 패턴

낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 우리는 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 `**낮은 결합도를 유지할 수 있는 설계를 선택**`해야 한다.

만약 Screening이 Movie에게 ‘계산하라’는 메시지를 요청하고 Discount Condition에게 ‘할인 여부를 판단하라’는 메시지를 전송한다면 할인 여부를 전송 받은 Screening에 다시 Movie에게 할인 여부를 알려야 하므로 Screening과 Discount Condition에 새로운 결합도가 생기고 Movie는 Screening에게 더 의존하게 된다.

## High Cohesion 패턴

높은 응집도도 모든 설계 결정에서 염두에 두어야 할 원리다. 우리는 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 `**높은 응집도를 유지할 수 있는 설계를 선택**`해야 한다.

만약 Screening이 Discount Condition에 직접 메시지를 전송하게 된다면 Discount Condition이 변경되었을 때 책임을 나눠가진 Movie와 Screening 둘 다 영향을 받으므로 낮은 응집도가 된다.

Movie는 ‘계산하라’는 책임을 할당 받았고 할인 여부는 계산과 관련되기 때문에 Movie가 Discount Condition에 메시지를 요청하는 것은 응집도에 영향을 주지 않는다.

그러므로 High Cohesion 패턴에서 볼 때 Sceening이 메시지를 전송하는 것보다 Movie가 메시지를 전송하는 설계를 선택해야 한다.

## Creator 패턴

어떤 방식이라도 반드시 생성되는 객체나 이미 관련될 필요가 있는 객체에게 객체 생성 책임을 할당해야 한다. 이미 사용해야 하는 객체에게 생성에 대한 책임을 할당할 때 이미 결합되어있으므로 결합도에 영향을 미치지 않는다.

그러므로 이미 존재하는 객체 사이의 관계를 이용하여 생성의 책임을 할당해서 낮은 결합도를 유지해야 한다.

예를 들어 ‘예매’에 대한 인스턴스를 생성해야 할 때 이미 ‘예매하라’는 책임을 가지고 있는 Screening에게 생성에 대한 책임을 할당하는 것이 가장 이상적이다.

## Polymorphism(다형성) 패턴

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라

1. `서로 다른 이유로 변경될 수 있는지` 찾아 보아야 한다. 한 가지 이상의 이유로 변경될 수 있다는 것은 연관성이 없는 기능이나 데이터가 하나의 클래스로 뭉쳐져 있다는 것을 의미한다.  `**변경의 이유에 따라 클래스를 분리**`해야한다. 
    - 응집도가 높은 클래스 → 코드가 변경되는 이유가 한 가지 이다.
    - 응집도가 낮은 클래스 → 한 가지 이상의 이유로 변경된다.
2. `인스턴스 변수가 초기화 되는 시점`을 살펴본다. 그리고 **`초기화 되는 속성을 기준으로 코드를 분리`**하자
    - 응집도가 높은 클래스 → 인스턴스가 생성될때 모든 속성이 함께 초기화
    - 응집도가 낮은 클래스 → 객체의 속성이 초기화 되는 시기가 다름
3. 메서드들이 `인스턴스 변수를 사용하는 방식`을 살펴보자. **`속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준`**으로 코드를 분리하자
    - 응집도가 높은 클래스 → 모든 메서드가 모든 속성을 사용
    - 응집도가 낮은 클래스 → 메서드들이 사용하는 속성에 따라 나뉨
4. `서로 다른 독립적인 타입이 존재하는지` 살펴보자.  서로 다른 `**타입을 두개의 클래스로 분리하고 해당 클래스가 사용하는 인스턴스 변수만 포함**`하자. 그렇게 될 경우 클래스들은 자신의 모든 인스턴스 변수를 함께 초기화 할 수있다.

## Protected variations 패턴

추상클래스나 인터페이스로 역할을 추상화한다면 그 안에 동일한 책임을 수행하는 다른 클래스들의 존재를 감출 수 있다. 곧 **`추상화가 타입을 캡슐화 한다`**는 의미다. 이처럼 변경을 캡슐화 할 수 있도록 책임을 할당하는 것을 변경 보호 패턴이라고 부른다.

1. `동일한 책임을 수행(역할)하는 클래스들`을 `**역할을 구현할 추상클래스나 인터페이스를 사용**`하자. 그렇다면 오직 역할에 대해서 만 결합되도록 의존성을 제한 할 수 있다.
    - **구현을 공유할 필요가 있다면** **추상클래스**를 사용
    - 구현을 공유할 필요 없이 **역할을 대체하는 객체들의 책임만 정의** 하고 싶다면 **인터페이스**를 사용

```html
❗클래스를 변경에따라 분리하고 인터페이스를 이용해 변경을 캡슐화 해라
  하나의 클래스가 여러타입의 행동을 한다면 다형성 패턴을 이용하여 분리하고, 
	예측가능한 변경으로 인해 여러 클래스들이 불안하다면 
	변경 보호 패턴에 따라 인터페이스 뒤로 변경을 캡슐화 해라. 
```

## 도메인의 구조가 코드의 구조를 이끈다.

책임 중심으로 협력을 설계할 때 클래스는 작고 오직 한 가지일 만을 수행하게 된다. 곧 책임이 적절하게 분배되어있다는것을 의미한다. 객체에게 중요한 것은 상태가 아니라 행동이다. 객체 지향 설계의 기본은 책임과 협력에 초점을 맞추는 것이다.

도메인 모델은 설계에 필요한 용어를 제공하는 것을 넘어 구현을 가이드 할 수 있는 모델을 선택해야 한다. 변경 또한 도메인 모델의 일부이고, 변경에 대한 직관이 반영되어야 설계가 유연할 수 있다. 객체지향은 도메인의 개념과 구조를 반영한 코드를 가능하게 만들기 때문에 도메인의 구조가 코드의 구조를 이끌어낸다.

## 코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다.

변경에 대비할 수 있는 두 가지 방법은 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하거나 **코드를 수정하지 않고도 변경을 수용 할 수 있도록 유연하게 설계하는 것**이다. 우리는 유연하게 설계하도록 해야 한다.

실행 중에 변경해야 한다는 요구가 들어올 경우

- 상속
    
    새로운 인스턴스를 생성한 후 필요한 정보를 복사해야 한다. 변경 전후의 인스턴스가 개념적으로 동일한 객체를 가리키지만, 물리적으로는 다른 객체다
    
- 합성
    
    새로운 클래스를 추가하고 클래스의 인스턴스를 합성된 독립적인 메서드에 전달하면 된다. 단지 합성 시켜진 메서드(ConditionPolicy)의 인스턴스를 교체하는 단순한 작업으로 바뀐다.
    

코드의 구조가 바뀌면 도메인에 대한 관점도 바뀐다. 도메인 모델은 도메인에 포함된 개념과 관계뿐만 아니라 도메인이 요구하는 유연성도 정확하게 반영한다. 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며 코드의 변화 맞춰 함께 변화해야 한다

# 책임 주도 설계의 대안

적절한 책임과 객체를 선택하는 일에 어려움을 느낀다면, 절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향 코드로 변경해 보자. 일단 실행되는 코드를 얻고 난 후 코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동 시킨다면 생각보다 훌륭한 설계를 얻게 된다.

주의 할 점은 `**코드를 수정한 후 겉으로 드러나는 동작이 바뀌어서는 안된다**`. 이처럼 유연성 높은 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 바꾸는 것을 리펙터링(Refactoring)이라고 한다.

1. 모든 절차가 집중되어있는 객체에 포함된 로직들을 `적절한 객체의 책임으로 분배하자.` 가장 먼저 할 일은 응`집도가 있는 수준으로 분해`하는 것이다.
    
    긴 메서드는 응집도가 낮기 때문에 이해하고 재사용 하기 어렵다. 유지 보수에 부정적인 영향을 미친다. 이런 메서드를 몬스터 메서드라 부른다.
    
    응집도가 높은 메서드는 변경되는 이유가 단 하나 여야 한다. 클래스가 작고 목적이 명확한 메서드들로 구성되어 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지 명확하게 보기 쉽고 목적이 분명하고 크기가 작은 메서드는 재사용도 쉽다.
    
    작은 메서도로 분해하면 전체적인 흐름을 이해하기 쉽고 한 번에 기억해야 하는 정보를 줄 일 수 있다.  변경하기도 쉽다. 각 메서드들은 단 하나의 이유에 의해서 만 변경되기 때문에 이런 메서들로만 구성된다면 응집도 높은 클래스가 만들어진다.
    
2. `변경의 이유가 다른 메서드들을 적절한 위치로 분배해야 한다.` 적절한 위치란 각 메서드가 사용하는 데이터를 정의하고 있는 클래스를 의미한다. 메서드가 사용하는 데이터를 저장하고 있는 클래스로 이동 시키면 된다.
    
    메서드를 다른 클래스로 이동시킬 떄는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적이다. 인자를 가지고 있는 메서드의 일부가 되기 때문에 인자를 전달 받을 필요가 없다.
    
    내부에서만 인스턴스 변수에 접근하기 떄문에 접근자 메서드를 제거할 수 있고 곧 내부 구현을 캡슐화 할 수 있게 된다. 그렇기 때문에 응집도 역시 높아지고, 내부 구현을 노출 시키는 접근자를 사용할 필요 없이 메시지를 통해서 만 협력할 수 있다.
    
3. `다형성 패턴`과 `변경 보호 패턴`을 이용해 코드를 분리하고 이동 시키자