# chapter1 객체, 설계

## 01. 티켓 판매 애플리케이션 구현하기

- 소극장은 홍보를 위해 초대장 이벤트를 진행했다
- 소극장에 입장하기 위해선 초대장 혹은 티켓이 필요하다
- 공연을 관람하기 원하는 관람객들은 티켓을 소지하고 있어야 한다
- 관람객은 초대장, 현금, 티켓 세 가지를 가지고 있다
- 이러한 설계를 바탕으로 소극장에 입장시키는 로직을 완성했다
- 많은 요소들에 대해 변경에 대비하면 낭비 일수도 있다ㅈ

## 02. 무엇이 문제인가

- 해당 로직의 문제는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다

### 로버트 마틴이 말하는 소프트웨어 모듈이 가져야 하는 세 가지 기능

- 모든 모듈은 제대로 실행돼야 한다
- 모든 모듈은 변경이 용이해야 한다
- 모든 모듈은 이해하기 쉬워야 한다

> → 현재 코드는 `변경 용이성`과 읽는 사람과의 `의사소통`이라는 목적을 만족시키지 못한다


### 예상을 빗나가는 코드

- 소극장이 여러분의 허락도 없이 매표소에 보관 중인 티켓과 현금에 마음대로 접근할 수 있다
    - 현재의 코드는 우리의 상식과는 너무나도 다르게 동작 → 코드를 읽는 사람과 `의사소통`하지 못한다
- 코드는 이해하기 위해서는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다
    - Theater 의 enter 메소드를 이해하기 위해 필요한 내용들
        - Audience 가 Bag 을 가지고 있다
        - Bag 안에는 현금과 티켓이 들어있다
        - TicketSeller 가 TicketOffice 에서 티켓을 판매한다
        - TicketOffice 안에 돈과 티켓이 보관돼 있다
    - Audience 와 TicketSeller 를 변경할 경우 Theater 도 함께 변경해야 한다 → `변경 용이`하지 못함

### 변경에 취약한 코드

- Theater 는 관람객이 가방을 들고 있고 판매원이 매표소에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다
    - 한 가지라도 바뀌면? → 해당 클래스뿐 아니라 이 클래스에 의존하는 모든 것을 변경해야 한다
    - 객체 사이의 **의존성(dependency)**과 관련된 문제
- 애플리케이션의 기능을 구현하는 데 필요한 `최소한의 의존성만 유지하고 불필요한 의존성을 제거`하는 것
- 객체 사이의 의존성이 과한 경우 **결합도(coupling)**가 높다고 말한다
- 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것

## 03. 설계 개선하기

- Theater가 관람객의 가방과 판매원의 매표소에 직접 접근한다 → 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다
- 관람객과 판매원을 자율적인 존재로 만들자

### 자율성을 높이자

- TicketSeller의 자율성 높이기
    - TicketSeller가 직접 TicketOffice를 처리하는 자율적인 존재가 되도록 설계하자
    - 1️⃣ Theater 의 enter 메소드의 내용을 TicketSeller 로 옮기자
    - 2️⃣ Theater 는 TicketSeller 에 추가된 sellTo 메서드를 호출한다
        - 결과적으로 `ticketOffice` 에 대한 접근은 오직 `TicketSeller` 안에서만 존재
        - TicketSeller는 ticketOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행하게됨
        - 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 `캡슐화(encapsulation)` 라고 한다
        - Theater 는 오직 TicketSeller 의 인터페이스(interface)에만 의존한다
        - TicketSeller 가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다

→ Theater 에서 TicketOffice 로의 의존성이 제거되었다

- Audience의 자율성 높이기
    - Audience가 직접 Bag을 처리하는 자율적인 존재가 되도록 설계하자
    - 현재는 TicketSeller 가 Audience 의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근 → 이를 캡슐화 해보자
    - 1️⃣ TicketSeller 의 sellTo 메서드에서 getBag 메서드에 접근하는 부분을 Audience 로 옮기자
    - 2️⃣ TicketSeller 는 Audience 의 buy 메서드를 호출한다
        - Audience 는 자신의 가방 안에 초대장이 들어있는지를 스스로 확인한다
        - 이제 자신의 가방을 제3자가 마음대로 꺼내볼 수 없게 되었다

### 무엇이 개선됐는가

- Audience 와 TicketSeller 가 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결
- 두 클래스의 변경은 Audience 와 TicketSeller 내부만으로 제한된다 → `변경 용이`

### 어떻게 한 것인가

- 자기 자신의 문제를 스스로 해결하도록 코드를 변경했다
- 우리의 직관을 따랐고 그 결과로 코드는 변경이 용이하고 이해 가능하도록 수정됐다
- Audience 는 외부의 누군가에게 자신의 가방을 열어보도록 허용하지 않는다
- TicketSeller 는 다른 누군가가 매표소 안을 마음대로 휘젓고 다니도록 허용하지 않는다
- 이해하기 쉽고 유연한 설계 획득!

### 캡슐화와 응집도

- 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이 핵심
- Theater 는 TicketSeller 의 내부에 대해 알지 못하고 단지 TicketSeller 의 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다

### 절차지향과 객체지향

- 첫번째 방법의 관점
    - Theater.enter → 프로세스(Process)
    - Audience, TicketSeller, Bag, TicketOffice → 데이터(Data)
    - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 절차적 프로그래밍(Procedural Programming)
    - 타인이 자신의 가방을 다음대로 헤집어 놓아도 아무런 불만을 가지지 않는 소극적인 존재
- 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다
- 두번째 방법의 관점
    - 자신의 데이터를 스스로 처리하도록 단계를 이동시켰다
    - Theater.enter → Audience 와 TicketSeller 의 내부로 이동
    - 데이터와 프로세스가 동일한 모듈 내부에 위치시키는 방식
    - 객체지향 프로그래밍(Object-Oriented Programming)

### 책임의 이동

- Theater에 몰려 있던 책임이 개별 객체로 이동한 것
- 각 객체는 자신을 스스로 책임진다
- 이러한 관점에서 객체지향 프로그래밍을 데이터와 프로세스를 하나의 단위로 통합해 놓은 방식으로 표현
- 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것
- 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당할 것이냐에 초점
- 의존성을 제가하여 객체 사이의 결합도를 낮추자
- 캡슐화는 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다

### 더 개선할 수 있다

- Bag 의 자율성 높이기
- TicketSeller 의 자율성 높이기
- 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다
- 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다

### 그래, 거짓말이다!

- Theater, Bag, TicketOffice 는 실세계에서는 자율적인 존재가 아니다
- 비록 현실에서는 수동적인 존재라도 일단 객체지향 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다
- 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙 → `의인화(anthropomorphism)`

## 04. 객체지향 설계

<aside>
💡 설계란 코드를 배치하는 것이다

</aside>

- 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다
- 개발이 진행되는 동안 요구사항은 바뀔 수밖에 없다
- 코드를 변경할 때 버그가 추가될 가능성이 높다

### 객체지향 설계

- 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다
- 변경 가능한 코드란 이해하기 쉬운 코드다
- 객체지향 패러다임은 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다
- 객체지향 세계에서 객체들 간의 상호작용은 객체 사이에 주고 받는 메시지로 표현된다
- 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다