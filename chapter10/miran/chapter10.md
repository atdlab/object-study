코드를 재사용하는 방법

- 전통적인 패러다임 → 코드를 복사한 후 수정
- 객체지향 패러다임 → 새로운 코드를 추가

객체지향에서 코드를 재사용하는 방법

- 상속 → 클래스안에 정의 된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가
- 합성 →

# 상속과 중복 코드

## DRY원칙(Don’t Repeat Yourself)

> 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야한다 [Hunt99]
> 

중복 여부를 판단하는 기준은 변경이다. 두 코드를 함께 수정해야 한다면 중복이다. 우리는 동일한 지식을 중복 하지 않아야 한다.

### 중복 코드가 가지는 문제점

- 중복 코드의 묶음은 모든 코드를 일관되게 수정해야 함
- 개별적으로 테스트해서 동일한 결과를 낳는지 확인해야 함

## 중복과 변경

### 중복 코드 살펴보기

1. **전화 요금 계산하는 클래스를 만들자**
    
    전화 요금은 통화 시간을 단위 시간당 요금으로 계산한다.
    
2. **‘심야 할인 요금제’ 추가 → 밤 10시 이후의 통화에 대해서 할인**
    
    기존 요금제를 복사해서 단위 요금을 변경해서 추가한다면 가장 빠르지만 중복 코드가 존재함으로 버그가 발생할 확률이 높다.
    
3. **통화 요금에 부과할 세금을 계산해라**
    
    세금을 추가 하기 위해 ‘심야 요금제’, ‘일반 요금제’ 모두 수정해야 한다.
    
    중복 코드 수정할 때 위험한 요소
    
    - 많은 코드 중에서 중복 코드를 식별하기 힘들다.
    - 식별한 코드를 서로 다르게 수정하기 쉽다.
    - 중복 코드는 새로운 중복 코드를 생산한다.

### 중복 코드를 제거하는 방법

1. **타입 코드 사용하기**
    
    요금제를 구분하는 타입 코드를 추가하고 타입 코드 값에 따라 로직을 분기 시켜 Phone과 NightDiscountPhone을 합친다.
    
    **→ 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도를 만든다.** 
    
2. **상속을 이용해서 중복 코드 제거하기**
    
    NightDiscountPhone이 Phone을 상속 받아 Phone클래스의 코드 대부분을 사용한다.
    
    **→ 개발자가 코드를 이해하기 어렵다. 상속 계층이 깊을 수록 더욱더 이해하기 어렵다. 부모 클래스를 정확히 이해해야 한다. 즉 결합도가 높아진다.**
    
    ```java
    **상속을 위한 경고**
    자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출 할 경우 
    두 클래스는 강하게 결합된다. 
    super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거해야 한다.
    ```
    

## 상속으로 인한 취약한 기반 클래스의 문제

부모클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스의 문제라 한다.

1. 겉으로 보기에는 안전한 방식으로 기반 클래스를 수정한 것처럼 보이더라도 새로운 행동이 **파생 클래스에게** 상속될 경우 파생 클래스의 잘못된 초래할 수 있기 때문에 **취약하다**
2. 상속 관계를 추가할수록 **전체 시스템의 결합도가 높아진다.** 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는데 용이하지만 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.
3. **캡슐화를 약화 시키고 결합도를 높인다.** 상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다. 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.

### 불필요한 인터페이스 상속 문제

부모 클래스에서 상속 받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다.

퍼블릭 인터페이스에 대한 고려 없이 단순히 코드를 재사용을 위해 상속을 이용하는 것은 위험하다. 불필요한 오퍼레이션이 인터페이스에 스며들 수 있기 때문이다.

```java
**상속을 위한 경고**
상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
```

### 메서드 오버라이딩의 오작용 문제

> 클래스가 상속되기를 원한다며 상속을 위해 클래스를 설계하고 문서화 해야 한다. 그렇지 않은 경우 상속을 금지시켜야한다 [조슈아 블로치]
> 

클래스에서 메서드 오버라이딩으로 인해 같은 클래스의 다른 메서드를 호출 할 수도 있다. 그럴 경우 문제가 없기 위해 코드를 중복시키게 된다. 또한 부모 클래스의 코드를 그대로 가지고 오지 못할 수 있다.

조슈아는 서브 클래스가 안전하기 위해 클래스의 상세 구현 내역을 기술해야 한다고 한다. 메서드가 같은 클래스의 다른 메서드를 호출하는지, 각각의 public이나 protected 메서드 및 생성자가 어떤 오버라이딩 가능한 클래스를 호출하는지, 어떤 순서로 하는지 결과에 따라 어떤 영향을 주는지.

**설계는 트레이드 오프 활동이다. 상속은 코드 재사용을 위해 캡슐화를 위반한다.**

```java
**상속을 위한 경고**
자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 
부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다
```

### 부모 클래스와 자식 클래스의 동시 수정 문제

자식 클래스가 부모 클래스의 메서드를 오버라이딩 하거나 불필요한 인터페이스를 상속 받지 않았을 때도 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다. **상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문이다.**

조슈아는 부모 클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 자식클래스는 부모 클래스와 보조에 맞춰서 진화해야 한다고 말한다.

```java
**상속을 위한 경고**
클래스를 상속하면 결합도로 인해 자식 클래스와 부모클래스의 구현을 영원히 변경하지 않거나 
자식클래스와 부모클래스를 동시에 변경하거나 둘중 하나를 선택할 수 밖에 없다.
```

## 상속으로 인한 피해를 최소화 할 수 있는 방법

### 추상화에 의존하자

자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만들어야 한다 정확하게 말하면 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.

### **상속을 도입할 때 따르는 원칙**

- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

### 차이를 메서드로 추출하라

- 변하는 것과 변하지 않는 것을 분리하라
- 변하는 부분을 찾고 이를 캡슐화 하라

### 중복 코드를 부모 클래스로 올려라

- 새로운 부모 클래스를 추가하라
- 두 메서드의 공통 부분을 새로운 부모 클래스로 이동시키자
    - 인스턴스 변수보다 메서드를 먼저 이동하라. 그러면 필요한 변수가 무엇인지 쉽게 알 수있다.
    - 메서드의 구현은 그대로 두고 공통 부분인 시그니처만 부모 클래스로 이동 시켜야 한다.
    - 메서드를 추상 메서드로 선언하고 자식 클래스에서 오버라이딩 할 수 있도록 protected로 선언하자

공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수 있다. 

### 추상화가 핵심이다

공통 코드를 옮기고 나면 각 클래스는 서로 다른 변경의 이유를 가진다. 각각 하나의 변경 이유 만을 가진다. 곧 이 클래스들은 **단일 책임 원칙을 준수하기 때문에 응집도가 높다.**

부모클래스의 구체적인 구현에 의존하지 않고 오직 추상화에 의존하면, 추상 메서드의 시그니처가 변경되지 않는 한 부모 클래스의 내부 구현이 변경 되더라도 자식 클래스는 영향을 받지 않는다. 그러므로 **낮은 결합도를 가지게 된다.**

부모 클래스가 자신의 내부에 구현된 추상메서드를 호출하며 추상화에 의존한다면 **의존성 역전의 원칙을 준수할 수 있다.** 

변경도 용이하다. 새로운 변경이 요구된다면 새로운 클래스를 추가 후 추상 메서드만 오버라이딩하면 된다. 그러면 다른 클래스를 수정할 필요가 없다. 확장에는 열려있고, 수정에는 닫혀 있기 때문에 **개방-폐쇄 원칙 역시 준수한다.**

```java
**추상화를 찾아내고 상속 계측 안의 클래스들이 그 추상화에 의존하도록 코드를 리펙터링하라.
차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라**
```

### 의도를 드러내는 이름 선택하기

구현의 목적을 명확하게 전달하는 이름으로 바꿔라. 

### 인스턴스 초기화 로직을 변경하라

클래스라는 도구는 메서드뿐만 아니라 인스턴스 변수도 함꼐 포함한다. 따라서 클래스 사이의 상속은 자식 클래스가 부모 클래스의 구현한 행동 뿐만 아니라 인스턴스 변수에 대해서도 결합되게 만든다.

인스턴스 변수의 목록이 변하지 않고 객체의 행동만 변한다면 상속 계층에 속한 각 클래스들을 독립적으로 진화시킬 수 있지만, 인스턴스 변수가 추가 되는 경우 자식클래슨느 자신의 인스턴스를 생성할 떄 부모 클래스에 정의된 변수를 초기화 해야하기 때문에 차연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미치게 된다.

하지만, 인스턴스 초기화 로직을 변경하는 것이 중복 코드를 만드는 것보다 낫다. 객체 생성 로직이 변경됐을 때 영향을 받는 부분을 최소화하려면 핵심 로직의 중복을 막는 것이 중요하다. **핵심 로직은 한 곳에 모아 놓고 조심스럽게 캡슐화 해야 한다. 그리고 공통적인 핵심 로직은 최대한 추상화해야한다.**

상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다. 메서드를 추가함으로서 결합을 어느 정도 완화할 수는 있지만 인스턴스 변수에 대한 결합을 제거할 수 있는 방법은 없다.

# 차이에 의한 프로그래밍

상속이 강력한 이유는 익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가할 수 있기 때문이다. 이처럼 기존 코드와 다른 부분 만을 추가함으로서 기능을 확장하는 방법을 차이에 의한 프로그래밍이라고 부른다. 상속을 이용하면 이미 존재하는 코드를 쉽게 재사용할 수 있기 떄문에 애플리케이션의 점진적인 정의가 가능해진다.

차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 것이다. **중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다. 코드를 재사용 하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다.** 중복 코드를 제거하기 위해 최대한 코드를 재사용 해야 한다.

코드를 재사용하면 코드의 품질은 유지하면서도 코드를 작성하는 노력과 테스트를 줄일 수 있다. 상속은 중복 코드를 제거하고 코드를 재사용할 수 있는 가장 유명한 방법이다.

```java
여러 클래스에 공통적으로 포함돼있는 중복 코드를 하나의 클래스로 모은다. 
원래 클래스들에서 중복 코드를 제거한 후 중복 코드가 옮겨진 클래스를 상속 관계로 연결한다.

코드를 컴파일하면 상속관계로 연결된 코드들이 하나로 합쳐진다. 따라서 상속을 사용하면 
여러 클래스 사이에서 재사용 가능한 코드를 하나의 클래스안으로 모을 수 있다.
```