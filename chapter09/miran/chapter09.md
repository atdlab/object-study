# CHAPTER09. 유연한 설계

# 개방-폐쇄 원칙

```java
소프트웨어 개체(클래스, 모듈 , 함수 등등)는 확장에 대해 열려있어야 하고 
수정에 대해서는 닫혀 있어야 한다
```

## 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

컴파일타임 의존성과 런타임 의존성은 다르다. 

개방-폐쇄 원칙을 따르는 설계는 변경이 있을 시 기존 코드를 수정하지 않고 새로운 클래스를 추가하는 것 만으로 구현할 수 있다. 또한 컴파일타임 의존성을 변경하지 않고 런타임 의존성만 변경 하여 쉽게 변경할 수 있다.

## 추상화가 핵심이다

`개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.`

추상화는 핵심적인 부분만 남기고 불필요한 부분을 생략한다. 즉 계방-폐쇄 원칙을 따르는 설계에서는 추상화 부분은 수정에 대해 닫혀 있고, 추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.

변하지 않는 부분을 고정하고 변하는 부분을 생략하는 추상화 매커니즘이 개방-폐쇄 원칙의 기반이 된다. 추상화의 생략된 부분을 구체화 함으로서 새로운 문맥에 맞게 기능을 확장할 수 있다. 따라서 추상화는 설계의 확장을 가능하게 한다.

명시적인 의존성과 의존성 해결 방법을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다. 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

추상화를 했다고 모든 수정에 대해 설계가 폐쇄 되는 것은 아니다. 변하는 것과 변하지 않는 것이 무엇인지 이해하고 추상화를 해야만 한다.

# 생성 사용 분리

`결합도가 높아질 수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다.`

객체 생성은 과도한 결합도를 초래하기도 한다.  이 때 문맥을 바꾸기 위한 유일한 방법은 코드를 직접 수정하는 것 뿐이다.

객체 생성은 피할 수 없다. 적절한 곳에 생성 해야만 한다. 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제인 것이다. 유연한 설계를 원한다면 객체와 관련된 책임을 서로 다른 객체로 분리해야 한다.

소프트웨어 시스템은 응용 프로그램 객체를 제작하고 의존성을 서로 연결하는 시작 단계와 실행 단계를 분리해야 한다.

분리하는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다. 현재의 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮김으로써 객체는 특정한 클라이언트에 결합되지 않고 독립적일 수 있다.

## FACTORY 추가하기

클라이언트에게 생성의 책임을 옮기면 클라이언트도 생성과 사용을 동시에 가지고 있게 된다. 이 경우 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 이 객체를 클라이언트가 사용하게 만들 수 있다. 이처럼 `객체 생성에 특화된 객체를 FACTORY`라 부른다.

클라이언트가 FACTORY를 만들고 객체 생성을 모두 FACTORY로 옮기고 사용한다면 클라이언트는 사용과 책임만 갖게 된다.

## 순수한 가공물에게 책임 할당하기

FACTORY는 도메인 모델에 속하지 않는다. FACTORY를 추가한 이유는 순수하게 기술적인 결정이다. 전체적으로 결합도를 낮추고 재사용성을 높이기 위해서 도메인 개념에게 할당되어 있던 객체 생성 책임을 도메인 개념과 아무런 상관이 없는 가공의 객체로 이동 시킨 것이다.

시스템을 객체로 분해하는 두 가지 방식

- 표현적 분해(representational decomposition)
    
    도메인에 존재하는 사물 또는 개념을 표현하는 객체를 이용해 시스템을 분해하는 것이다. 도메인과 소프트웨어 사이의 표현적 차이를 최소화 하는 것을 목적으로 한다.
    
- 행위적 분해 (behavioral decomposition)
    
    실제로 동작하는 애플리케이션의 데이터베이스를  접근을 위한 객체 같이 도메인의 개념을 초월하는 기계적인 개념을 분해하는 것이다.
    

설계자가 편의를 위해 임의로 만들어낸 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 PURE FABRICATION(순수한 가공물)이라고 부른다. 순수한 가공물은 보통 특정한 해동을 표현한다.

객체 지향 애플리케이션은 도메인의 개념뿐만 아니라 설계자들이 임의적으로 창조한 인공적인 추상화를 포함하고 있다. 설계자로서의 우리의 역할은 도메인 추상화를 기반으로 애플리케이션 로직을 설계하는 동시에 품질 측면에서 균형을 맞추는데 필요한 객체를 창조하는 것이다.

도메인의 본절적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하고 인공적인 객체를 창조해서 유연한 설계를 만들어야 한다.

## 의존성 주입

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달에서 의존성을 해결하는 방법을 의존성 주입(Dependency Injection)이라고 한다. 의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭이다.

의존성 주입에서 의존성을 해결하는 방법은 아래와 같다. 

- 생성자 주입 → 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- setter 주입 → 객체 생성 후 setter 메서드를 이용해 의존성 해결
    
    언제라도 의존 대상을 교체할 수 있지만, 객체가 올바로 생성하기 위해 어떤 의존성이 필수적인 지를 명시적으로 표현할 수 없다.
    
    setter는 자바 언어의 방식에서 유래했고, C#에서는 프로퍼티 주입이라고 한다.
    
- 메서드 주입 → 메서드 실행 시 인자를 이용해 의존성 해결
    
    객체가 올바로 생성되는데 필요한 의존성을 명확하게 표현할 수 있지만 의존성이 한두 개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 방법이 더 낫다.
    
- 인터페이스 주입
    
    근본적으로 setter주입과 동일하다. 단지 어떤 대상을 어떻게 주입할지 인터페이스를 통해 명시적으로 선언한다는 차이만 있다. 
    

## 숨겨진 의존성은 나쁘다

### SERVICE LOCATOR 패턴

의존성을  해결할 객체들을 보관하는 일종의 저장소를 SERVICE LOCATOR라고 한다. SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해 줄 것을 요청한다. SERVICE LOCATOR패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지 어디에 있는지 몰라도 되게 해준다.

SERVICE LOCATOR의 가장 큰 단점은 의존성을 감춘다. 의존성에 대한 정보가 어디에도 표시지 않는다. SERVICE LOCATOR에서 의존성은 암시적이며 코드 깊숙한 곳에 숨겨져 있다.

의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일 타임이 아닌 런타임에 발견된다. 또 단위 테스트의 작성도 어렵다. 일반적인 단위 테스트는 테스트 케이스 단위로 테스트에 사용될 객체들을 새로 생성하는 기능을 제공한다. SERVICE LOCATOR는 내부적으로 객체를 관리하기 때문에 모든 단위테스트에 걸쳐 SERVICE LOCATOR 상태를 공유한다. 이것은 각 단위 테스트는 서로 고립되어있다는 원칙을 위반한 것이다. 숨겨진 의존성은 의존성을 이해하기 위해 내부 구현을 이해할 것을 강요하기 때문에 캡슐화를 위반한다.

```java
가급적 의존성을 객체의 퍼블릭 인터페이스에 노출해라.
의존성을 숨기면 코드를 이해하기도, 수정하기도 어려워진다.
의존성 주입은 의존성을 명시적으로 명시할 수 있는 하나의 방법이다.
```

# 의존성 역전 원칙

## 추상화와 의존성 역전

객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 어떤 협력에서 중요한 정책이나 의사 결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스(이하 상위 클래스)다. 이런 상위 클래스가 하위 수준의 클래스(이하 하위 클래스)에 의존한다면 하위 수준의 변경에 의해 상위 수준의 변경해야 하므로 상위 클래스가 영향을 받게 될 것이다.

의존성은 변경의 전파와 관련된 것이기 때문에 설계의 변경 영향을 최소화하도록 의존성을 관리해야 한다. 상위 클래스는 어떤 식으로도 하위 클래스에 의존하지 않아야 한다. 하위 클래스에 의존한 상위 클래스는 재사용할 때도 하위 클래스가 필요하므로 재사용하기 어렵다.

`상위 클래스와 하위 클래스를 모두 추상화에 의존하자.` 그렇게 되면 하위 클래스 변경에도 상위 클래스가 영향을 받지 않는다. 또한 상위 클래스의 재사용에도 하위 클래스가 얽히지 않는다.

```java
유연하고 재사용 가능한 설계를 원한다면 
**모든 의존성의 방향이 추상 클래스나 인터페이스와 같이 추상화를 따라야 한다.** 
구체 클래스는 의존성의 시작점 일 뿐 목적이 되어서는 안된다.
```

### 의존성 역전 원칙(Dependency Inversion Principle, DIP)

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

## 의존성 역전 원칙과 패키지

객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다. 

의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스 소유권도 역전 시켜야 한다. 잘 설계된 애플리케이션은 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치 시킨다. 

유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러다임이 고수하는 의존성의 방향을 역전 시켜야 한다. 객체지향 패러다임에서 상위 수준의 모듈과 하위 수준 모듈이 모두 추상화에 의존한다. 즉 객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

# 유연성에 대한 조언

## 유연한 설계는 유연성이 필요할 때만 옳다

유연성은 복잡성을 수반한다. 유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다. 설계가 유연할 수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 따라서 유연함은 단순성과 명확성의 희생 위에서 자라난다.

불필요한 유연성은 불필요한 복잡성을 낳는다. 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라. 하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어라

정적인 프로그램과 동적인 프로세스 사이의 간극을 줄이기 위해 최선을 다해야 하며 이를 통해 프로그램과 진행 과정 사이를 가능한 한 일치 시켜야 한다.

## 협력과 책임이 중요하다

설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다. 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 필요가 없다.

객체의 역할과 책임이 자리 잡기 전 성급하게 객체 생성에 집중하면, 객체 생성과 관련된 불필요한 세부 사항에 객체를 결합시킨다. 책임의 불균형 상태에서 객체 생성 책임을 지우는 것은 하부 매커니즘에 종속적으로 만들 확률이 높다.

```java
중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추고 객체를 생성 하라. 
책임 관점에서 객체들 간의 균형이 잡혀 있다면 생성을 담당할 객체를 선택하는 것은 쉬워진다. 
**모든 책임이 자리 잡은 후 
마지막 시점에 객체를 생성하는 방법에 대한 결정을 내리는 것이 적당하다.**
```

의존성을 관리해야 하는 이유는 역할, 책임 협력의 관점에서 설계가 유연하고 재사용이 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중하라