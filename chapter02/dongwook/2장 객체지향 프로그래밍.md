# 2장 객체지향 프로그래밍

## 주의 깊게 읽은 문장을 작성하고, 떠오르는 생각도 같이 적도록 한다.

- 어떤  클래스가  필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라 (41p)
> 클래스와 객체의 차이를 고민하면서 책을 읽어보자

- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다 (41p)
	- 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라 

- 도메인: 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다 (41p)

- 클래스의 내부와 외부를 구분해야 하는 이유는 무엇일까? 그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. => 프로그래머에게 구현의 자유를 제공한다. (43p)

- 객체는 상태와 행동을 함꼐 가지는 복합적인 존재이다. 스스로 판단하고 행동하는 자율적인 존재라는 것이다. 객체지향 패러다임 이전에는 데이터와 기능은 독립적인 존재였다. 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있다. (44p)

- 설계가 필요한 이유는 번경을 관리하기 위해서라는 것을 기억하라. 객체 사이의 의존성을 적절히 관리함으로써 변경에 대한 파급효과를 제어할 수 있는 다양한 방법을 제공한다. (45p)

- 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다. 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다. (47p)

> 평소 단순히 Long, Integer 같은 자료형을 반환하는 메서드를 작성하면서 표현력이 약하다고 생각이 들었지만 클래스 하나를 더 만드는 것이 과한 것 같아 작성하기를 머뭇거렸었다. 이제는 객체를 더 적극적으로 활용해서 코딩해야겠다.

- 메세지와 메서드를 구분하는 것은 매우 중요하다. 객체지향 패러다임이 유연하고, 확장 가능하며, 재사용 가능한 설계를 낳는다는 명성을 얻게 된 배경에는 메세지와 메서드를 명확하게 구분한 것도 단단히 한몫한다. 메세지와 메서드의 구분에서부터 다형성의 개념이 출발한다. (49p)

- 쉽게 재사용이 가능하고, 확장 가는ㅇ한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다. 하지만 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기는 어려워진다. 설계는 트레이드 오프의 산물이다. (59p)

- 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다 (59p)

- 상속이 가치 있는 이유는 부모 클래스가 제공하는 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 상속의 목적이 메서드나 인스턴스 변수를 재사용이라는 일반적인 인식과 거리가 있다. 인터페이스는 객체가 이해할 수 있는 메세지의 목록을 정의한다는 것을 기억하라. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다. (61p)

- Movie 클래스는 DiscountPolicy 클래스에게 메세지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 Movie 와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다. 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다. (63p)

- 다형성이란 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 다형성을 구현하는 방법은 다양하지만 메세지에 응답하기 위해 실행될 메서드를 실행 시점에 결정한다는 공통점이 있다. 이를 지연 바인딩, 동적 바인딩이라고 한다. (반대는 초기 바인딩, 정적 바인딩) (63p)

- 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. (66p)

- 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다. (70p)
	1. 캡슐화를 위반한다.
		- 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 이는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
	2. 설계가 유연하지 않다.
		- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

- 합성은 인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법이다. 부모 클래스와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 인터페이스를 통해 약하게 결합된다. (72p)
	- 상속이 가지는 두 가지 문제점을 모두 해결한다. 코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.

- 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수밖에 없다. (72p)

- 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다. (72p)

