# CHAPTER.02 객체지향 프로그래밍

# 01. 영화 예매 시스템

실제 예매하는 대상은 영화가 아니라 상영이다. 예매자는 돈을 지불 하고 특정 시간에 상영되는 영화를 관람할 수 있다. 특정한 조건을 만족하는 예매자는 요금 할인을 받을 수 있다.

## 요구 사항

### 영화 (기본 정의)

- 제목, 상영 시간, 가격

### 상영 (실제 영화를 보는 사건)

- 영화 제목, 상영 일자, 상영 시간, 순번

### 할인 조건

- 할인이 가능한지 여부, 순번, 시간

### 할인 정책

할인 요금을 결정한다. 할인 정책은 영화 당 하나만 할당 할 수 있고(null도 가능), 할인 조건은 여러 개 일 수 있다. 

- **금액 할인 정책** - 일정 금액을 할인
- **비율 할인 정책** - 정가의 일정 비율을 할인

```jsx
할인 조건을 만족하는지 검사
- Y → 할인 정책을 이용해 할인 요금을 계산
- N → 정가로 계산한다
금액을 지불 하고 예매를 완료
예매 정보 생성
- 제목, 상영정보, 인원, 정가, 결제 금액
```

# 02. 객체지향 프로그래밍을 향해

## 협력, 객체, 클래스

객체지향 프로그램을 작성할 때 가장 고려해야 하는 것은 클래스가 아닌 객체에 초점을 맞춰야 한다.

1. 어떤 객체가 필요한지 고민해 한다. 클래스는 공통적인 상태와 행동을 공유하는 객체를 추상화 한 것이다
    
    객체들이 어떤 **상태와 행동을 가지는 지를 결정** → 클래스의 윤곽을 잡을 수 있다.
    
2. 객체는 독립적인 존재가 아닌 **협력하는 공동체의 일원**으로 봐야 한다. 객체는 서로 도움을 주거나 의존하는 협력 적인 존재로 바라보면 설계는 유연하고 확장 가능해진다.
    1. 객체들의 모양과 윤곽을 잡는다. 
    2. 공통된 특성과 상태를 가진 객체들을 타입으로 분류
    3. 타입을 기반으로 클래스를 구현한다.

## 도메인의 구조를 따르는 프로그램 구조

사용자가 어떠한 문제를 해결하기 위해 프로그램을 사용하는 것을 도메인이라고 한다. 

객체지향 패러다임은 초기 단계부터 프로그램을 구현하는 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있다. 요구 사항과 프로그램을 객체라는 동일한 관점에서 보기 때문에 도메인을 구성하는 개념이 객체와 클래스로 매끄럽게 연결 될 수 있다.

영화(Movie)는 여러 번 상영될 수 있다. 

- 영화는 할인 정책(DiscountPolicy)이 하나만 할당 되거나 없을 수 있다(=필수가 아님).
- 할인 정책은 할인 조건(DiscountCondition)을 포함하고 하나 이상 할당 되어야 한다(=필수).
- 할인 정책의 종류는 금액 할인 정책(AmountDiscountPolicy)과 비율 할인 정책(PercentDiscountPolicy)이 있다.
- 할인 조건의 종류는 순번 조건(SequenceDiscountCondition)과 기간 조건(PeriodDiscountCondition)이 있다.

상영(Screening)은 여러 번 예매(Reservation) 될 수 있다.

```jsx
Reservation
->
Screening
->
Movie
->
DiscountPolicy[0이거나 1] {AmountDiscountPolicy, PercentDiscountPolicy} 
->
DiscountCondition[1개이상] {SequenceDiscountCondition, PeriodDiscountCondition}
```

## 클래스를 구현하기

Screening은 상영을 구현한다.

- 변수는 **영화(movie), 순번(squence), 시간(whenScreened)**
- **getStartTime** 메서드는 상영 시작 시간을 반환한다.
- **isSequence** 메서드는 순번의 일치 여부를 검사한다.
- **getMovieFee** 메서드는 기본 요금을 반환한다.

변수의 가시성은 private이고 메서드의 가시성은 public이다. 클래스를 사용할 때 핵심은 private, public을 결정하는 것이다. **경계의 명확성이 객체의 자율성을 보장**하기 때문이다. 그래야지 구현이 자유로울 수 있다.

### 자율적인 객체

객체지향은 객체 단위 안에 데이터와 기능을 함께 묶어(=캡슐화) 문제 영역의 아이디어를 표현한다.객체지향은 외부에서 객체가 어떤 상태인지 어떤 생각인지 알 수 없고 결정에 직접적인 개입을 할 수 없게 접근을 통제 할 수 있는 접근 제어(접근 제어는 public, protected, private과 같은 접근 수정자를 제공) 매커니즘도 함께 제공해 해서  객체가 스스로 상태를 자유롭게 관리, 판단, 행동할 수 있는 자율적인 존재로 만든다.

- 객체는 **상태(state)와 행동(behavior)를 함께 가지는 복합적인 존재**이다.
- 객체는 **스스로 판단하고 행동하는 자율적인 존재**이다.
- 객체는 캡슐화와 접근 제어로 인해 퍼블릭 인터페이스와 구현으로 나뉜다. 일반적으로 상태는 숨기고 행동만 외부에 공개해야 한다. 클래스의 속성은 private, 일부 메서드만 public으로 선언해야 한다.
    - 퍼블릭 인터페이스(Public Interface) → 외부에서 접근 가능
    - 구현(implementation) → 오직 내부에서만 접근 가

### 프로그래머의 자유

프로그래머의 역할

- 클래스 작성자 → 새로운 데이터 타입을 프로그램에 추가
- 클라이언트 프로그래머 → 클래스 작성자가 추가한 데이터를 사용

프로그래머의 목표

- 클래스를 엮어서 애플리케이션을 빠르고 안정적으로 구축
- 클래스 작성자는 클라이언트 프로그래머에게 접근 제어 매커니즘으로 필요한 부분만 공개하고 나머지는 마음대로 접근 하지 못하도록 숨겨야 한다. 이것을 구현 은닉이라고 한다.
→ 클라이언트가 private에 접근할 경우 컴파일 오류를 내보낸다.
    - 클라이언트 프로그래머는 내부 구현을 무시한 채 인터페이스 만으로 클래스를 사용할 수 있다.
    - 클래스 작성자는 public을 바꾸지 않는 한 외부 영향을 걱정하지 않고 내부 구현을 마음대로 수정할 수 있다.

## 협력하는 객체들의 공동체

영화를 예매하는 기능을 구현하는 메서드를 살펴보자

1. Screening의 reserve(영화 예매) 메서드는 Reservation(영화 예매 정보) 인스턴스를 생성해서 반환한다.
2. Reservation의 생성자에게 reserve의 결과(customer(예매자의 정보), audienceCount(인원수))를 전달한다. Reservation의 속성은 customer(고객), screening(상영 정보), fee(예매 요금), 인원 수(audienceCount)이다.
3. reserve메서드는 caculateFee(private) 메서드를 호출해서 요금을 계산한다.
4. caculateFee 메서드는 요금을 계산하기 위해 Movie의 caculationMovieFee 호출한다
5. caculationMovieFee는 1인 당 예매 요금을 반환한다.
6. Screening은 caculationMovieFee(1인당 예매 요금)에 reserve의 결과(인원수)를 곱한다 

객체를 이용해 도메인의 의미를 좀 더 명시적이고 분명할 수 있게 구현 해야 한다. 개념을 명시적으로 표현하는 것은 설계의 명확성과 유연성을 높이는 길이다. 

- Money 클래스 의 경우 Long타입의 변수 사용한다고 했다.  그러나 Long타입은 변수의 크기나 연산자의 종류를 표현할 수 있으나 하지만 금액과 관련된 값이라는 의미를 전달하거나 다른 곳에서 금액에 관련되어 중복되어 사용되는 막을 수 없다.

영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하여 상호작용 한다. 이 상호작용을 협력(Collaboration)이라고 부른다.

객체지향 프로그램을 작성할 때는 상호작용을 하기 위해 어떤 객체가 필요한지 결정하고 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

## 협력에 관한 짧은 이야기

객체는 다른 객체의 퍼블릭 인터페이스를 수행하도록 요청(request)할 수 있다. 요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.

객체 간의 상호작용 할 수 있는 유일한 방법은 메시지를 전송하고 수신하는 것 뿐이다. 

메시지를 수신한 객체는 스스로의 결정에 따라 자유롭게 메시지를 처리한다. 그리고 그 메시지를 처리하기 위한 방법을 메서드라고 한다.

메시지와 메서드를 명확하게 구분하는 것은 유연하고, 확장 가능하며, 재사용 가능 한 설계를 하게 한다.

지금까지 ‘Screening이 Movie의 caculateFee 메서드를 호출한다’ 했지만 ‘메시지를 전송한다’ 가 더 적절하다. Screening은 Movie안에 caculateFee 메서드가 있는지 알 수 없기 때문이다. 단지 Movie가 요금 계산을 응답할 것이라고 믿고 전송할 뿐이다. Movie는 caculateFee가 아닌 다른 메서드를 통해서 요금 계산을 응답할 수 도 있다. 메시지를 처리하는 것은 Movie 스스로의 문제이다.

이것이 객체가 메시지를 처리하는 방법을 자율적으로 결정 지을 수 있다고 말한 이유이다.

# 03. 할인 요금 구하기

## 할인 요금 계산을 위한 협력 시작하기

1. Movie의 속성은 title(제목), runningTime(상영 시간), fee(기본 요금), discountPolicy(할인 정책)이다. 이 속성의 값은 생성자에게 받는다.
2. Movie의 caculateMovieFee는 discountPolicy에게 요청을 해서 caculateDiscountAmount(할인 요금)을 응답 받는다.
3. Movie는 fee(기본 요금)에서 응답 받은 caculateDiscountAmount(할인 요금)를 차감한다

여기서 우리는 어떠한 할인 정책을 사용할 것인지 결정하는 코드를 알지 못한다. 단지 discountPolicy에게 요청을 할 뿐이다. 여기에는 상속과 다형성이라는 두 가지 개념이 숨겨져 있다. 그 기반에는 추상화라는 원리가 있다.

## 할인 정책과 할인 조건

### DiscountPolicy(할인 정책)

DiscountPolicy(할인 정책)는 AmountDiscountPolicy(금액 할인 정책)과 PercentDiscountPolicy(비율 할인 정책)으로 구분된다. 둘은 유사하지만 조금 다르다. 그래서 부모 클래스인 DiscountPolicy에 공통 코드를 보관하고 둘은 이 클래스를 상속 받을 예정이다. 그래서 새로운 클래스를 생성할 필요가 없기 떄문에 이것을 추상 클래스라고 한다.

1. DiscountPolicy의 변수는 DiscountConditions의 conditions라는 리스트를 가지고 있기 때문에 하나의 정책에 여러가지 조건을 가질 수 있다.
2. caculationDiscountAmount는 전체 조건에 순서대로 discountConditions의 isSatisfiedBy를 요청한다.
3. isSatisfiedBy는 할인 조건이 맞는 지를 검사하고 true나 false를 응답한다. 이 값을 추상 메서드(공통코드)인 getDiscountAmout에 할인 요금을 요청한다.
    - true → getDiscountAmout에서 요금을 계산해 할인 요금을 응답한다.
    - false → 할인 요금을 0으로 응답한다.
    
    DiscountPolicy는 기본적인 알고리즘의 흐름을 구현하고 실제 요금을 계산하는 부분을 getDiscountAmout에 위임한다. 실제로는 AmountDiscountPolicy, PercentDiscountPolicy(자식 클래스)에서 오버 라이딩한 메서드가 실행 된다. 이런 식으로 처리하는 과정을 TEMPLATE METHOD 패턴이라고 한다.
    

```jsx
DiscountPolicy {
	getDiscountAmout = 공통 코드를 모아놓은 추상클래스
	AmountDiscountPolicy = 자식 클래스
  PercentDiscountPolicy = 자식 클래스
}
```

### DiscountCondition(할인 조건)

DiscountCondition은 SequenceCodition(순번 조건), PeriodCondition(기간 조건)을 가지고 있다. 둘은 추상 클래스 isSatisfiedBy로 할인이 가능한 지 여부를 검사하고 true, false를 반환한다. 

SequenceCodition의 변수는 squence(순번), PeriodCondition의 변수는 

- SequenceCodition은 할인 조건 가능 여부를 순번으로 확인한다.
변수 → squence(순번)
isSatisfiedBy는 squence가 일치 할 경우 true, 아닐 경우 false로 응답한다.
- PeriodCondition은 할인 조건 가능 여부를 상영 시작 시간이 특정 기간 안에 포함되는 지를 확인한다
변수 → dayOfWeek(요일), startTime(시작 시간), endTime(종료 시간)
isSatisfiedBy는 dayOfWeek가 일치 하고 startTime과 endTime 사이에 포함될 경우 true, 아닐 경우 false로 응답한다.

### AmountDiscountPolicy, PercentDiscountPolicy(할인 정책)

- AmountDiscountPolicy는 할인 조건을 만족할 경우 일정한 금액을 할인 해준다.
    - 이 클래스는 getDiscountAmout를 오버라이딩 한다.
    - 할인 요금은 discountAmount에 저장한다.
- PercentDiscountPolicy는 할인 조건을 만족할 경우 일정 비율을 차감한다.
    - 이 클래스는 getDiscountAmout를 오버라이딩 한다.
    - 할인 비율은 percent에 저장한다.

```jsx
**오버라이딩**
부모클래스에 정의된 같은 이름과 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는 것
특징: 자식 클래스는 오버라이딩한 부모를 가리기 때문에 외부에서 부모클래스를 볼 수 없다.

**오버로딩**
메서드의 이름은 같지만 파라미터의 목록이 다른 경우
특징: 원래의 메서드를 가리지 않기 때문에 외부에서 두 메서드 모두를 호출 할 수 있다.
```

## 할인 정책 구성하기

Movie는 하나 이하의 DiscountPolicy를 설정할 수 있고, DiscountPolicy는 여러 개의 DiscountCondition을 가질 수 있게 선언되어있다. 이처럼 초기에 필요한 정보를 전달하도록 강제 할 경우 올바른 상태의 객체를 생성할 수 있다.

```jsx
Movie 클래스 {
	영화제목
	상영시간
	예매금액
	할인정책(할인정책의 정보)
}
```

- 아바타
    - 상영 시간 → 120분
    - 예매 금액 → 10,000원
    - 금액 할인 정책(800원, 순번 조건(1), 순번 조건(10), 기간 조건(월, 10:00, 11:59), 기간 조건(목, 10:00,20:59)
- 타이타닉
    - 상영 시간 → 180분
    - 예매 금액 → 11,000원
    - 비율 할인 정책(0.1, 기간 조건(목, 14:00, 16:59), 순번 조건(2), 기간 조건(목,10:00,13:59))

# 04. 상속과 다형성

Movie클래스에 할인 정책이 무엇인지 판단 하지 않는다. 이 질문에 답하기 위해서는 상속과 다형성에 대해 알아야 한다.  먼저 의존성의 개념을 살펴보고 상속과 다형성을 이용해 특정한 조건을 선택해서 실행하는 방법을 알아보자

### 컴파일 시간 의존성과 실행 시간 의존성

Movie는 DiscountPolicy와 연결되어있다. 

AmountDiscountPolicy와 PercentDiscountPolicy는 둘의 추상 클래스인 DiscountPolicy를 상속 받는다. → **서로의 클래스를 접근할 수 있거나 호출이 가능한 경우 이 클래스들 사이에 의존성이 존재한다고 한다.**

실제로는 영화 요금을 계산하기 위해서는 추상 클래스인 DiscountPolicy가 아니라 AmountDiscountPolicy나 PercentDiscountPolicy가 필요하다. 따라서 Movie는 AmountDiscountPolicy나 PercentDiscountPolicy의 인스턴스에 의존 해야 한다. 

하지만 코드 상에서 Movie는 DiscountPolicy만 의존하고 있다. Movie 코드 작성 시점에서는 AmountDiscountPolicy나 PercentDiscountPolicy를 인식하지 못했는데 실행 시점에서 협력하는 이유는 Movie 인스턴스를 생성 할 때 인자로 AmountDiscountPolicy나 PercentDiscountPolicy를 전달 했기 때문이다.

이와 같이 **코드의 의존성과 실행 시점의 의존성이 다를 수 있다. → 클래스 사이의 의존성과 객체 사이의 의존성이 다를 수 있다.** 

코드의 의존성과 실행 시점의 의존성이 다를 경우

- 단점:  객체를 생성하고 연결하는 부분을 찾아야 하기 때문에 코드를 이해하고 디버깅하기 어렵다.
- 장점:  유연하고 쉽게 재 사용 할 수 있고, 확장이 가능한 객체지향 설계를 할 수 있다.

### 차이에 의한 프로그래밍

상속은 클래스를 추가할 때 기존의 클래스를 가져와 약간만 추가하거나 수정해서 새로운 클래스를 만들거나, 기존의 클래스를 전혀 수정하지 않고 재사용 하는 것을 말한다.

상속을 이용하면 기존의 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함 시킬 수 있다. 그래서 기존의 클래스를 기반으로 새로운 클래스를 간편하게 만들 수 있고, 기존의 클래스의 구현은 공유하면서 행동이 다른 자식 클래스를 추가 할 수 있다.

이렇게 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라고 한다.

상속의 두 개의 클래스의 관계를 정의하는 방법이다. 상속을 사용하면 코드 중복을 제거하고 여러 클래스 사이에서 동일한 코드를 사용할 수 있다.

### 상속과 인터페이스

상속이 가치 있는 이유는 자식 클래스가 부모 클래스가 제공하는 모든 인터페이스를 물려받기 때문이다. 그렇기 때문에 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있어서 외부 객체는 부모 클래스와 자식 클래스를 동일한 타입으로 간주 할 수 있다.

Movie의 caculateMovieFee 메서드는 DiscountPolicy에 cacularteDiscountAmout 메시지를 요청했다. cacularteDiscountAmout은 DiscountPolicy를 상속 받은 AmountDiscountPolicy, PercentDiscountPolicy에도 포함되어 있다. 그러나 Movie는 어떤 클래스의 인스턴스 인지가 중요한 것이 아니라 cacularteDiscountAmout를 요청 할 수 있다는 사실이 중요하다.

자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받아 부모 클래스를 대신할 수 있다. 컴파일러는 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허한다.

그렇게 때문에 Movie에서 DiscountPolicy(부모)이라고 타입이 정해져 있어도 AmountDiscountPolicy, PercentDiscountPolicy(자식)를 대신해서 할당할 수 있다.

이처럼 자식 클래스가 부모 클래스를  대신하는 것을 업캐스팅이라고 한다.

### 다형성

메시지와 메서드는 다르다. Movie가 DiscountPolicy에 cacualateDiscountAmount메시지를 전송하면 Movie와 협력하는 객체가 무엇인가 에 따라 그 객체에서 오버라이딩 한 메서드가 실행 된다.  이를 다형성이라고 한다.

코드에서는 Movie는 DiscountPolicy에 메시지를 전송하지만 실제로 실행 시점에서는 AmountDiscountPolicy나 PercentDiscountPolicy가 실행 된다.

다형성은 컴파일 시점 의존성과 실행 시점 의존성이 다를 수 있다는 사실을 기반으로 한다. 코드에서는 Movie는 DiscountPolicy에 의존하지만 실행에서는 Movie는 AmountDiscountPolicy나 PercentDiscountPolicy에 의존한다. 

그렇기 때문에 동일한 메시지를 수신 했을 때 객체의 타입에 따라 다른 메서드를 실행 시키고 다르게 응답할 수 있다. 따라서 이 객체들은 모두 동일한 인터페이스를 물려받았기 때문에 같은 메시지를 이해할 수 있어야 한다.

다형성을 구현하는 방법은 다양하지만 모두 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다. 곧, 메시지와 메서드를 실행 시점에 바인딩 한다. 이것을 지연 바인딩(↔ 초기 바인딩), 또는 동적 바인딩(↔정적 바인딩)이라고 한다. 이로 인해 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 각 메서드에 연결할 수 있다.

```jsx
상속
- 구현상속(=서블클래싱)
	코드를 재사용하기 위해 사용
- 인터페이스상속(=서브타이핑)
	다형적인 협력을 위해 코드를 공유할 경우
구현상속보다는 인터페이스 상속을 지양해야한다. 
그렇지 않으면 변경에 취약한 코드를 생성하게 될 것이다.
```

### 인터페이스와 다형성

DiscountPolicy와 같이 구현을 공유하기 위해 추상클래스를 만들어 내부 구현을 함께 상속받았다..

그러나 DiscountCondition은 구현을 공유할 필요가 없기 때문에 순수하게 인터페이스만을 공유해 타입계층을 구현 할 수 있다.

SequenceDiscountCondtion과 PeriodDiscountCondtion은 같은 인터페이스를 공유하기 때문에 isSatisfiedBy를 이해 할 수 있고, DiscountPolicy입장에서는 DiscountCondition를 대신해 이 둘을 사용할 수 있다. 이 경우는 자식클래스가 부모클래스를 대신하는 업캐스팅이 적용 된다

# 05. 추상화와 유연성

### 추상화의 힘

할인 정책(할인 조건)은 금액 할인 정책(순번 조건), 비율 할인 정책(기간 조건) 보다 더 추상적이다. 프로그래밍 언어에서는 인터페이스에 초점을 두기 때문이다. 할인 정책(할인 조건)은 caculationDiscountAmount, isSatifiedBy와 같이 같은 계층에 속해있는 클래스들이 공통으로 가질 수 있는 인터페이스를 정의하고 자식 클래스가 구현을 결정할 수 있도록 위임한다.

- 추상화의 계층만 따로 떼어 놓고 살펴보면 요구 사항의 정책을 높은 수준에서 서술 할 수 있다.
추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 세부 사항에 억눌리지 않고 상위 개념 만으로 설명할 수 있다. 곧 추상화를 이용한 설계는 필요에 따라 표현의 수준을 조정할 수 있다. **추상화를 이용한다는 것은 기본적으로 애플리케이션의 협력 흐름을 기술 한다는 것과 같다. 상위 정책에서 하위 정책으로 흐른다.** 새로운 자식 클래스는 상위 협력 흐름을 그대로 따른다. 그렇기 때문에 **재사용이 가능한 설계의 기본인 디자인패턴, 프레임워크 모두 추상화를 이용해 객체지향 매커니즘을 활용한다**.
- 추상화를 이용하면 설계가 좀 더 유연해진다.
추상화를 이용해 상위 정책을 표현하면 구조를 수정하지 않고 새로운 기능을 쉽게 추가하고 확장할 수 있다.

### 유연한 설계

할인 정책이 설정되지 않은 경우 예외 케이스로 취급 되기 때문에 일관성이 있던 협력 방식이 무너지게 된다. 할인 정책이 있는 경우 요금 계산의 책임은 DiscountPolicy에 있지만 없을 경우 Movie에 경우에 있게 되기 때문에 조건문을 사용 해야 한다. 그러나 예외 케이스를 최소화하고 일정하게 유지할 수 있게 조건문을 최소화 해야 한다. 즉, 예외 케이스도 계산의 책임을 DiscountPolicy에 유지 시킨다.

DiscountPolicy에 NoneDiscountPolicy 클래스를 추가 시키면서 기존의 코드를 수정하지 않고 애플리케이션의 기능을 확장할 수 있다.  

추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하게 대문이다. Movie는 DiscountPolicy의  특정 정책에 묶이지 않고, DiscountPolicy는 DiscountCondition의 특정 조건에 묶이지 않는다. 그렇기 때문에 어떠한 클래스와도 협력이 가능하다. 이것은 부모클래스가 추상적이기 때문이다. 컨텍스트 독립성이라 불리는 이 개념은유연한 설계가 필수인 분야에서 진가를 발휘한다.

### 추상 클래스와 인터페이스 트레이드오프

NoneDiscountPolicy는 getDiscountAmount를 호출하지 않기 때문에 어떤 값을 반환하더라도 상관없다. NoneDiscountPolicy는 caculationDiscountAmount를 오버라이딩 하도록 변경하자

DiscountPolicy를 DefaultDiscountPolicy로 변경하고 NoneDiscountPolicy가 DiscountPolicy 인터페이스를 구현하도록 변경한다(=트레이드오프). 곧 DiscountPolicy는 DefaultDiscountPolicy, NoneDiscountPolicy를 포함한다.

### 코드 재사용

상속은 코드를 재사용하기 위해 널리 사용되지만 재사용을 위해 상속보다는 합성이 더 좋은 방법이다. 합성이란 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 것을 말한다.

Movie를 상속 받아 AmountDiscountMovie, PercentDiscountMovie 클래스를 추가하고 그들이 DiscountPolicy를 재사용하는 것을 합성이라고 한다. 합성은 기존의 방법과 가능적인 관점에서 동일하다.

### 상속

상속은 코드의 재사용을 위해 사용되지만, 두 가지 단점이 있다.

- 캡슐화를 위반한다.
상속을 이용하기 위해서는 부모클래스의 구조를 알고 있어야한다. 그렇기 때문에 부모클래스의 구현이 자식클래스에게 노출 되기 때문에 캡슐화가 약화된다. 캡슐화가 약하면 자식클래스가 부모 클래스에 강하게 결합되게 된다. 그럴 경우 부모클래스를 변경할 때 자식클래스도 변경되기 때문에 변경하기 어려워진다.
- 설게를 유연하게 만들지 못한다
상속은 클래스와의 관계를 컴파일 시에 결정하기 때문에 실행 시점에서 객체의 종류를 변경하는 것이 불가능하다. 인스턴스 변수로 연결한 기존 방법을 사용하면 실행 시점에 객체를 변경할 수 있다. (Movie안에 DiscountPolicy를 변경할 수 있는 클래스를 추가)

### 합성

Movie는 요금을 계산하기 위해 DiscountPolicy를 재사용한다. 이 방법은 부모클래스와 자식클래스가 컴파일 시점에 DiscountPolicy를 통해 약하게 결합된다는 것이다.

Movie는 DiscountPolicy가 caculateDiscountAmount메서드를 제공한다는 사실만 알고 내부 구현에 대해서는 알지 못한다 이처럼 인터페이스에 정의된 메시지를 통해서 만 재사용하는 것을 합성이라고 한다.

- 인터페이스에 정의된 메시지만 재사용이 가능하므로 구현을 효과적으로 캡슐화 할 수 있다.
- 의존하는 인스턴스를 교체하는 것이 쉽기 때문에 설계가 유연하다.

설계에서는 상속과 합성을 함께 사용해야한다. 프로그래밍의 관점에 너무 치우쳐서 객체지향의 본질을 놓쳐서는 안된다. 가장 중요한 것은 협력에 참여하는 객체들의 상호작용이다

객체지향의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의하고 적절한 책임을 할당하는 것이다.