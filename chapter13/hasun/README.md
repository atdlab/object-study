# chapter13. 서브클래싱과 서브타이핑

### 상속이 사용되는 두 가지 용도

- 타입 계층을 구현하는 것
    - `부모 클래스`는 **일반적인 개념**을 구현하고 `자식 클래스`는 **특수한 개념**을 구현
- 코드 재사용
    - 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다
    - 하지만 이 경우 부모 클래스와 자식 클래스가 강하게 결합되어 변경하기 어려운 코드를 낳는다

> 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 **타입 계층을 구현하는 것**이어야 한다
>
- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는, 객체의 행동을 기반으로 타입 계층을 구성해야 한다

### 객체지향 프로그래밍과 객체기반 프로그래밍

- 객체기반 프로그래밍(Object-Based Programming)
    - `상태와 행동을 캡슐화`한 **객체를 조합**해서 프로그램을 구성하는 방식
- 객체지향 프로그래밍(Object-Oriented Programming)
    - **객체들을 조합**해서 애플리케이션을 개발하지만, 상속과 다형성을 지원


## 01. 타입

### 개념 관점의 타입

- 우리가 인지하는 세상의 사물의 종류
- 예시 ) 프로그래밍 언어
    - 자바, 루비, 자바스크립트, C
    - → 프로그래밍 언어라는 `타입`으로 분류
    - 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 `인스턴스(instance)` == `객체`

---

- 심볼(symbol)
    - 타입에 이름을 붙인 것 → `프로그래밍 언어`
- 내연(intension)
    - 타입의 정의
    - 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
    - 예시 ) 프로그래밍 언어
        - 컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합
- 외연(extension)
    - 타입에 속하는 객체들의 집합
    - 예시 ) 프로그래밍 언어
        - 자바, 루비, 자바스크립트, C

### 프로그래밍 언어 관점의 타입

- 프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다
- 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 애플리케이션에 의해 결정
- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
    - 자바에서 ‘+’ 연산자는 원시형 숫자 타입, 문자열 타입의 객체에는 사용 가능하지만 다른 클래스의 인스턴에 대해서는 사용할 수 없음
    - 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다
    - 예시 ) 자바
        - a + b
            - int ⇒ a와 b를 더한다
            - string ⇒ 두 문자열을 하나의 문자열로 합친다
    - 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입이다

> 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다
>

### 객체지향 패러다임 관점의 타입

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
    - 프로그래밍 언어의 관점에서 타입은 호출 가능한 오퍼레이션의 집합을 정의
    - 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미
        - 따라서 객체가 수신할 수 있는 메시지의 종류를 정의하는 것
- `객체가 수신할 수 있는 메시지의 집합`
    - 퍼블릭 인터페이스

> 객체에게 중요한 것은 속성이 아니라 행동이다
>

## 02. 타입 계층

### 타입 사이의 포함관계

- 타입은 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다
- 타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다
- 타입은 다른 타입에 포함될 수 있기 때문에 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다
- `다른 타입을 포함하는 타입`은 포함되는 타입보다 일반화된 의미 표현
    - `외연(집합)` 관점에서는 더 크고 `내연(정의)` 관점에서는 더 일반적
- `포함되는 타입`은 좀 더 특수하고 구체적
    - `외연(집합)` 관점에서는 더 작고 `내연(정의)` 관점에서는 더 특수

### 객체지향 프로그래밍과 타입 계층

- 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준 = ‘퍼블릭 인터페이스’

## 03. 서브클래싱과 서브타이핑

- 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 어떤 조건을 만족해야 할까?

### 언제 상속을 사용해야 하는가?

- 상속의 올바른 용도는 타입 계층을 구현하는 것
- 상속 관계가 is-a 관계를 모델링하는가?
    - 일반적으로 “[자식 클래스]는 [부모 클래스]다” 라고 말해도 이상하지 않다면
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야함
    - 이를 자식 클래스와 부모 클래스 사이의 `행동 호환성`이라고 함

### is-a 관계

- 어떤 타입 S가 다른 타입 T의 일종이라면 당연히 “타입 S는 타입 T다(S is-a T)”라고 말할 수 있어야 한다
- 객체지향 언어는 프로그래밍 언어다 = 클래스 기반 언어는 객체지향 언어다
- 어휘적인 정의가 아니라 기대되는 `행동`에 따라 타입 계층을 구성해야 한다
- 슈퍼타입과 서브타입 관계에서는 is-a보다 `행동 호환성`이 더 중요하다

### 행동 호환성

- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 `행동에 연관성이 없다면` is-a 관계를 사용하지 말아야 한다
- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점

### 클라이언트의 기대에 따라 계층 분리하기

- 예시 ) 펭귄과 새
    - Flyer, Walker 인터페이스 분리
    - 혹은 합성을 이용하기
- 클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있다
- ISP(Interface Segregation Principle)
    - 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙

> 여러분이 지금 만드는 애플리케이션이 비행에 대한 지식을 전혀 쓰지 않으며 나중에도 쓸 일이 없을 것이라면, 날 수 있는 새와 날지 않는 새를 구분하지 않는 것이 탁월한 선택
>

### 서브클래싱과 서브타이핑

- 서브클래싱(subclassing)
    - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다
    - 서브클래싱을 구현 상속(implementation infheritance) 또는 클래스 상속(class inheritance) 이라고 부르기도 한다
- 서브타이핑(subtyping)
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다
    - 이때 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다
    - 서브타이핑을 인터페이스 상속(interface inheritance) 이라고 부른다

> 인터페이스 상속(서브 타이핑)은 객체가 다른 곳에서 사용될 수 있음을 의미한다
>

## 04. 리스코프 치환 원칙

- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다